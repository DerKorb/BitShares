// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "multibit.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace wallet {

namespace {

const ::google::protobuf::Descriptor* PeerAddress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PeerAddress_reflection_ = NULL;
const ::google::protobuf::Descriptor* EncryptedPrivateKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EncryptedPrivateKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* Key_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Key_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Key_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Script_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Script_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionInput_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionInput_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionOutput_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionOutput_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionConfidence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionConfidence_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TransactionConfidence_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TransactionConfidence_Source_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Transaction_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Transaction_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Transaction_Pool_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Transaction_Purpose_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ScryptParameters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScryptParameters_reflection_ = NULL;
const ::google::protobuf::Descriptor* Extension_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Extension_reflection_ = NULL;
const ::google::protobuf::Descriptor* Wallet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Wallet_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Wallet_EncryptionType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_multibit_2eproto() {
  protobuf_AddDesc_multibit_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "multibit.proto");
  GOOGLE_CHECK(file != NULL);
  PeerAddress_descriptor_ = file->message_type(0);
  static const int PeerAddress_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerAddress, ip_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerAddress, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerAddress, services_),
  };
  PeerAddress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PeerAddress_descriptor_,
      PeerAddress::default_instance_,
      PeerAddress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerAddress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerAddress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PeerAddress));
  EncryptedPrivateKey_descriptor_ = file->message_type(1);
  static const int EncryptedPrivateKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedPrivateKey, initialisation_vector_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedPrivateKey, encrypted_private_key_),
  };
  EncryptedPrivateKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EncryptedPrivateKey_descriptor_,
      EncryptedPrivateKey::default_instance_,
      EncryptedPrivateKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedPrivateKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedPrivateKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EncryptedPrivateKey));
  Key_descriptor_ = file->message_type(2);
  static const int Key_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, private_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, encrypted_private_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, public_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, creation_timestamp_),
  };
  Key_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Key_descriptor_,
      Key::default_instance_,
      Key_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Key));
  Key_Type_descriptor_ = Key_descriptor_->enum_type(0);
  Script_descriptor_ = file->message_type(3);
  static const int Script_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Script, program_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Script, creation_timestamp_),
  };
  Script_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Script_descriptor_,
      Script::default_instance_,
      Script_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Script, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Script, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Script));
  TransactionInput_descriptor_ = file->message_type(4);
  static const int TransactionInput_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionInput, transaction_out_point_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionInput, transaction_out_point_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionInput, script_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionInput, sequence_),
  };
  TransactionInput_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TransactionInput_descriptor_,
      TransactionInput::default_instance_,
      TransactionInput_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionInput, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionInput, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TransactionInput));
  TransactionOutput_descriptor_ = file->message_type(5);
  static const int TransactionOutput_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionOutput, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionOutput, script_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionOutput, spent_by_transaction_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionOutput, spent_by_transaction_index_),
  };
  TransactionOutput_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TransactionOutput_descriptor_,
      TransactionOutput::default_instance_,
      TransactionOutput_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionOutput, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionOutput, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TransactionOutput));
  TransactionConfidence_descriptor_ = file->message_type(6);
  static const int TransactionConfidence_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, appeared_at_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, overriding_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, work_done_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, broadcast_by_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, source_),
  };
  TransactionConfidence_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TransactionConfidence_descriptor_,
      TransactionConfidence::default_instance_,
      TransactionConfidence_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionConfidence, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TransactionConfidence));
  TransactionConfidence_Type_descriptor_ = TransactionConfidence_descriptor_->enum_type(0);
  TransactionConfidence_Source_descriptor_ = TransactionConfidence_descriptor_->enum_type(1);
  Transaction_descriptor_ = file->message_type(7);
  static const int Transaction_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, pool_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, lock_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, updated_at_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, transaction_input_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, transaction_output_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, block_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, block_relativity_offsets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, confidence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, purpose_),
  };
  Transaction_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Transaction_descriptor_,
      Transaction::default_instance_,
      Transaction_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transaction, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Transaction));
  Transaction_Pool_descriptor_ = Transaction_descriptor_->enum_type(0);
  Transaction_Purpose_descriptor_ = Transaction_descriptor_->enum_type(1);
  ScryptParameters_descriptor_ = file->message_type(8);
  static const int ScryptParameters_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScryptParameters, salt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScryptParameters, n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScryptParameters, r_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScryptParameters, p_),
  };
  ScryptParameters_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ScryptParameters_descriptor_,
      ScryptParameters::default_instance_,
      ScryptParameters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScryptParameters, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScryptParameters, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ScryptParameters));
  Extension_descriptor_ = file->message_type(9);
  static const int Extension_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Extension, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Extension, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Extension, mandatory_),
  };
  Extension_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Extension_descriptor_,
      Extension::default_instance_,
      Extension_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Extension, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Extension, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Extension));
  Wallet_descriptor_ = file->message_type(10);
  static const int Wallet_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, network_identifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, last_seen_block_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, last_seen_block_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, last_seen_block_time_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, watched_script_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, encryption_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, encryption_parameters_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, extension_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, key_rotation_time_),
  };
  Wallet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Wallet_descriptor_,
      Wallet::default_instance_,
      Wallet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Wallet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Wallet));
  Wallet_EncryptionType_descriptor_ = Wallet_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_multibit_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PeerAddress_descriptor_, &PeerAddress::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EncryptedPrivateKey_descriptor_, &EncryptedPrivateKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Key_descriptor_, &Key::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Script_descriptor_, &Script::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TransactionInput_descriptor_, &TransactionInput::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TransactionOutput_descriptor_, &TransactionOutput::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TransactionConfidence_descriptor_, &TransactionConfidence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Transaction_descriptor_, &Transaction::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ScryptParameters_descriptor_, &ScryptParameters::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Extension_descriptor_, &Extension::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Wallet_descriptor_, &Wallet::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_multibit_2eproto() {
  delete PeerAddress::default_instance_;
  delete PeerAddress_reflection_;
  delete EncryptedPrivateKey::default_instance_;
  delete EncryptedPrivateKey_reflection_;
  delete Key::default_instance_;
  delete Key_reflection_;
  delete Script::default_instance_;
  delete Script_reflection_;
  delete TransactionInput::default_instance_;
  delete TransactionInput_reflection_;
  delete TransactionOutput::default_instance_;
  delete TransactionOutput_reflection_;
  delete TransactionConfidence::default_instance_;
  delete TransactionConfidence_reflection_;
  delete Transaction::default_instance_;
  delete Transaction_reflection_;
  delete ScryptParameters::default_instance_;
  delete ScryptParameters_reflection_;
  delete Extension::default_instance_;
  delete Extension_reflection_;
  delete Wallet::default_instance_;
  delete Wallet_reflection_;
}

void protobuf_AddDesc_multibit_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016multibit.proto\022\006wallet\"A\n\013PeerAddress\022"
    "\022\n\nip_address\030\001 \002(\014\022\014\n\004port\030\002 \002(\r\022\020\n\010ser"
    "vices\030\003 \002(\004\"S\n\023EncryptedPrivateKey\022\035\n\025in"
    "itialisation_vector\030\001 \002(\014\022\035\n\025encrypted_p"
    "rivate_key\030\002 \002(\014\"\345\001\n\003Key\022\036\n\004type\030\001 \002(\0162\020"
    ".wallet.Key.Type\022\023\n\013private_key\030\002 \001(\014\022:\n"
    "\025encrypted_private_key\030\006 \001(\0132\033.wallet.En"
    "cryptedPrivateKey\022\022\n\npublic_key\030\003 \001(\014\022\r\n"
    "\005label\030\004 \001(\t\022\032\n\022creation_timestamp\030\005 \001(\003"
    "\".\n\004Type\022\014\n\010ORIGINAL\020\001\022\030\n\024ENCRYPTED_SCRY"
    "PT_AES\020\002\"5\n\006Script\022\017\n\007program\030\001 \002(\014\022\032\n\022c"
    "reation_timestamp\030\002 \002(\003\"\203\001\n\020TransactionI"
    "nput\022\"\n\032transaction_out_point_hash\030\001 \002(\014"
    "\022#\n\033transaction_out_point_index\030\002 \002(\r\022\024\n"
    "\014script_bytes\030\003 \002(\014\022\020\n\010sequence\030\004 \001(\r\"\177\n"
    "\021TransactionOutput\022\r\n\005value\030\001 \002(\003\022\024\n\014scr"
    "ipt_bytes\030\002 \002(\014\022!\n\031spent_by_transaction_"
    "hash\030\003 \001(\014\022\"\n\032spent_by_transaction_index"
    "\030\004 \001(\005\"\234\003\n\025TransactionConfidence\0220\n\004type"
    "\030\001 \001(\0162\".wallet.TransactionConfidence.Ty"
    "pe\022\032\n\022appeared_at_height\030\002 \001(\005\022\036\n\026overri"
    "ding_transaction\030\003 \001(\014\022\r\n\005depth\030\004 \001(\005\022\021\n"
    "\twork_done\030\005 \001(\003\022)\n\014broadcast_by\030\006 \003(\0132\023"
    ".wallet.PeerAddress\0224\n\006source\030\007 \001(\0162$.wa"
    "llet.TransactionConfidence.Source\"O\n\004Typ"
    "e\022\013\n\007UNKNOWN\020\000\022\014\n\010BUILDING\020\001\022\013\n\007PENDING\020"
    "\002\022\025\n\021NOT_IN_BEST_CHAIN\020\003\022\010\n\004DEAD\020\004\"A\n\006So"
    "urce\022\022\n\016SOURCE_UNKNOWN\020\000\022\022\n\016SOURCE_NETWO"
    "RK\020\001\022\017\n\013SOURCE_SELF\020\002\"\236\004\n\013Transaction\022\017\n"
    "\007version\030\001 \002(\005\022\014\n\004hash\030\002 \002(\014\022&\n\004pool\030\003 \001"
    "(\0162\030.wallet.Transaction.Pool\022\021\n\tlock_tim"
    "e\030\004 \001(\r\022\022\n\nupdated_at\030\005 \001(\003\0223\n\021transacti"
    "on_input\030\006 \003(\0132\030.wallet.TransactionInput"
    "\0225\n\022transaction_output\030\007 \003(\0132\031.wallet.Tr"
    "ansactionOutput\022\022\n\nblock_hash\030\010 \003(\014\022 \n\030b"
    "lock_relativity_offsets\030\013 \003(\005\0221\n\nconfide"
    "nce\030\t \001(\0132\035.wallet.TransactionConfidence"
    "\0225\n\007purpose\030\n \001(\0162\033.wallet.Transaction.P"
    "urpose:\007UNKNOWN\"Y\n\004Pool\022\013\n\007UNSPENT\020\004\022\t\n\005"
    "SPENT\020\005\022\014\n\010INACTIVE\020\002\022\010\n\004DEAD\020\n\022\013\n\007PENDI"
    "NG\020\020\022\024\n\020PENDING_INACTIVE\020\022\":\n\007Purpose\022\013\n"
    "\007UNKNOWN\020\000\022\020\n\014USER_PAYMENT\020\001\022\020\n\014KEY_ROTA"
    "TION\020\002\"N\n\020ScryptParameters\022\014\n\004salt\030\001 \002(\014"
    "\022\020\n\001n\030\002 \001(\003:\00516384\022\014\n\001r\030\003 \001(\005:\0018\022\014\n\001p\030\004 "
    "\001(\005:\0011\"8\n\tExtension\022\n\n\002id\030\001 \002(\t\022\014\n\004data\030"
    "\002 \002(\014\022\021\n\tmandatory\030\003 \002(\010\"\223\004\n\006Wallet\022\032\n\022n"
    "etwork_identifier\030\001 \002(\t\022\034\n\024last_seen_blo"
    "ck_hash\030\002 \001(\014\022\036\n\026last_seen_block_height\030"
    "\014 \001(\r\022!\n\031last_seen_block_time_secs\030\016 \001(\003"
    "\022\030\n\003key\030\003 \003(\0132\013.wallet.Key\022(\n\013transactio"
    "n\030\004 \003(\0132\023.wallet.Transaction\022&\n\016watched_"
    "script\030\017 \003(\0132\016.wallet.Script\022C\n\017encrypti"
    "on_type\030\005 \001(\0162\035.wallet.Wallet.Encryption"
    "Type:\013UNENCRYPTED\0227\n\025encryption_paramete"
    "rs\030\006 \001(\0132\030.wallet.ScryptParameters\022\017\n\007ve"
    "rsion\030\007 \001(\005\022$\n\textension\030\n \003(\0132\021.wallet."
    "Extension\022\023\n\013description\030\013 \001(\t\022\031\n\021key_ro"
    "tation_time\030\r \001(\004\";\n\016EncryptionType\022\017\n\013U"
    "NENCRYPTED\020\001\022\030\n\024ENCRYPTED_SCRYPT_AES\020\002B\035"
    "\n\023org.bitcoinj.walletB\006Protos", 2389);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "multibit.proto", &protobuf_RegisterTypes);
  PeerAddress::default_instance_ = new PeerAddress();
  EncryptedPrivateKey::default_instance_ = new EncryptedPrivateKey();
  Key::default_instance_ = new Key();
  Script::default_instance_ = new Script();
  TransactionInput::default_instance_ = new TransactionInput();
  TransactionOutput::default_instance_ = new TransactionOutput();
  TransactionConfidence::default_instance_ = new TransactionConfidence();
  Transaction::default_instance_ = new Transaction();
  ScryptParameters::default_instance_ = new ScryptParameters();
  Extension::default_instance_ = new Extension();
  Wallet::default_instance_ = new Wallet();
  PeerAddress::default_instance_->InitAsDefaultInstance();
  EncryptedPrivateKey::default_instance_->InitAsDefaultInstance();
  Key::default_instance_->InitAsDefaultInstance();
  Script::default_instance_->InitAsDefaultInstance();
  TransactionInput::default_instance_->InitAsDefaultInstance();
  TransactionOutput::default_instance_->InitAsDefaultInstance();
  TransactionConfidence::default_instance_->InitAsDefaultInstance();
  Transaction::default_instance_->InitAsDefaultInstance();
  ScryptParameters::default_instance_->InitAsDefaultInstance();
  Extension::default_instance_->InitAsDefaultInstance();
  Wallet::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_multibit_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_multibit_2eproto {
  StaticDescriptorInitializer_multibit_2eproto() {
    protobuf_AddDesc_multibit_2eproto();
  }
} static_descriptor_initializer_multibit_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int PeerAddress::kIpAddressFieldNumber;
const int PeerAddress::kPortFieldNumber;
const int PeerAddress::kServicesFieldNumber;
#endif  // !_MSC_VER

PeerAddress::PeerAddress()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PeerAddress::InitAsDefaultInstance() {
}

PeerAddress::PeerAddress(const PeerAddress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PeerAddress::SharedCtor() {
  _cached_size_ = 0;
  ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0u;
  services_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PeerAddress::~PeerAddress() {
  SharedDtor();
}

void PeerAddress::SharedDtor() {
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_address_;
  }
  if (this != default_instance_) {
  }
}

void PeerAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PeerAddress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PeerAddress_descriptor_;
}

const PeerAddress& PeerAddress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

PeerAddress* PeerAddress::default_instance_ = NULL;

PeerAddress* PeerAddress::New() const {
  return new PeerAddress;
}

void PeerAddress::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ip_address()) {
      if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
        ip_address_->clear();
      }
    }
    port_ = 0u;
    services_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PeerAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes ip_address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ip_address()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }
      
      // required uint32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_services;
        break;
      }
      
      // required uint64 services = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_services:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &services_)));
          set_has_services();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PeerAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes ip_address = 1;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->ip_address(), output);
  }
  
  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }
  
  // required uint64 services = 3;
  if (has_services()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->services(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PeerAddress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes ip_address = 1;
  if (has_ip_address()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->ip_address(), target);
  }
  
  // required uint32 port = 2;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->port(), target);
  }
  
  // required uint64 services = 3;
  if (has_services()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->services(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PeerAddress::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes ip_address = 1;
    if (has_ip_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ip_address());
    }
    
    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }
    
    // required uint64 services = 3;
    if (has_services()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->services());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PeerAddress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PeerAddress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PeerAddress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PeerAddress::MergeFrom(const PeerAddress& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip_address()) {
      set_ip_address(from.ip_address());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_services()) {
      set_services(from.services());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PeerAddress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PeerAddress::CopyFrom(const PeerAddress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeerAddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void PeerAddress::Swap(PeerAddress* other) {
  if (other != this) {
    std::swap(ip_address_, other->ip_address_);
    std::swap(port_, other->port_);
    std::swap(services_, other->services_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PeerAddress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PeerAddress_descriptor_;
  metadata.reflection = PeerAddress_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EncryptedPrivateKey::kInitialisationVectorFieldNumber;
const int EncryptedPrivateKey::kEncryptedPrivateKeyFieldNumber;
#endif  // !_MSC_VER

EncryptedPrivateKey::EncryptedPrivateKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EncryptedPrivateKey::InitAsDefaultInstance() {
}

EncryptedPrivateKey::EncryptedPrivateKey(const EncryptedPrivateKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EncryptedPrivateKey::SharedCtor() {
  _cached_size_ = 0;
  initialisation_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encrypted_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EncryptedPrivateKey::~EncryptedPrivateKey() {
  SharedDtor();
}

void EncryptedPrivateKey::SharedDtor() {
  if (initialisation_vector_ != &::google::protobuf::internal::kEmptyString) {
    delete initialisation_vector_;
  }
  if (encrypted_private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete encrypted_private_key_;
  }
  if (this != default_instance_) {
  }
}

void EncryptedPrivateKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EncryptedPrivateKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EncryptedPrivateKey_descriptor_;
}

const EncryptedPrivateKey& EncryptedPrivateKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

EncryptedPrivateKey* EncryptedPrivateKey::default_instance_ = NULL;

EncryptedPrivateKey* EncryptedPrivateKey::New() const {
  return new EncryptedPrivateKey;
}

void EncryptedPrivateKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_initialisation_vector()) {
      if (initialisation_vector_ != &::google::protobuf::internal::kEmptyString) {
        initialisation_vector_->clear();
      }
    }
    if (has_encrypted_private_key()) {
      if (encrypted_private_key_ != &::google::protobuf::internal::kEmptyString) {
        encrypted_private_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EncryptedPrivateKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes initialisation_vector = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_initialisation_vector()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encrypted_private_key;
        break;
      }
      
      // required bytes encrypted_private_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrypted_private_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_private_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EncryptedPrivateKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes initialisation_vector = 1;
  if (has_initialisation_vector()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->initialisation_vector(), output);
  }
  
  // required bytes encrypted_private_key = 2;
  if (has_encrypted_private_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->encrypted_private_key(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EncryptedPrivateKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes initialisation_vector = 1;
  if (has_initialisation_vector()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->initialisation_vector(), target);
  }
  
  // required bytes encrypted_private_key = 2;
  if (has_encrypted_private_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->encrypted_private_key(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EncryptedPrivateKey::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes initialisation_vector = 1;
    if (has_initialisation_vector()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->initialisation_vector());
    }
    
    // required bytes encrypted_private_key = 2;
    if (has_encrypted_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_private_key());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EncryptedPrivateKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EncryptedPrivateKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EncryptedPrivateKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EncryptedPrivateKey::MergeFrom(const EncryptedPrivateKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_initialisation_vector()) {
      set_initialisation_vector(from.initialisation_vector());
    }
    if (from.has_encrypted_private_key()) {
      set_encrypted_private_key(from.encrypted_private_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EncryptedPrivateKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EncryptedPrivateKey::CopyFrom(const EncryptedPrivateKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptedPrivateKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void EncryptedPrivateKey::Swap(EncryptedPrivateKey* other) {
  if (other != this) {
    std::swap(initialisation_vector_, other->initialisation_vector_);
    std::swap(encrypted_private_key_, other->encrypted_private_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EncryptedPrivateKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EncryptedPrivateKey_descriptor_;
  metadata.reflection = EncryptedPrivateKey_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Key_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Key_Type_descriptor_;
}
bool Key_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Key_Type Key::ORIGINAL;
const Key_Type Key::ENCRYPTED_SCRYPT_AES;
const Key_Type Key::Type_MIN;
const Key_Type Key::Type_MAX;
const int Key::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Key::kTypeFieldNumber;
const int Key::kPrivateKeyFieldNumber;
const int Key::kEncryptedPrivateKeyFieldNumber;
const int Key::kPublicKeyFieldNumber;
const int Key::kLabelFieldNumber;
const int Key::kCreationTimestampFieldNumber;
#endif  // !_MSC_VER

Key::Key()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Key::InitAsDefaultInstance() {
  encrypted_private_key_ = const_cast< ::wallet::EncryptedPrivateKey*>(&::wallet::EncryptedPrivateKey::default_instance());
}

Key::Key(const Key& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Key::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encrypted_private_key_ = NULL;
  public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  creation_timestamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Key::~Key() {
  SharedDtor();
}

void Key::SharedDtor() {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
    delete encrypted_private_key_;
  }
}

void Key::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Key::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Key_descriptor_;
}

const Key& Key::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

Key* Key::default_instance_ = NULL;

Key* Key::New() const {
  return new Key;
}

void Key::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_private_key()) {
      if (private_key_ != &::google::protobuf::internal::kEmptyString) {
        private_key_->clear();
      }
    }
    if (has_encrypted_private_key()) {
      if (encrypted_private_key_ != NULL) encrypted_private_key_->::wallet::EncryptedPrivateKey::Clear();
    }
    if (has_public_key()) {
      if (public_key_ != &::google::protobuf::internal::kEmptyString) {
        public_key_->clear();
      }
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
    creation_timestamp_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Key::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .wallet.Key.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wallet::Key_Type_IsValid(value)) {
            set_type(static_cast< ::wallet::Key_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_private_key;
        break;
      }
      
      // optional bytes private_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_private_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_private_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_public_key;
        break;
      }
      
      // optional bytes public_key = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_label;
        break;
      }
      
      // optional string label = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_creation_timestamp;
        break;
      }
      
      // optional int64 creation_timestamp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_creation_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &creation_timestamp_)));
          set_has_creation_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_encrypted_private_key;
        break;
      }
      
      // optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrypted_private_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_encrypted_private_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Key::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .wallet.Key.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional bytes private_key = 2;
  if (has_private_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->private_key(), output);
  }
  
  // optional bytes public_key = 3;
  if (has_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->public_key(), output);
  }
  
  // optional string label = 4;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->label(), output);
  }
  
  // optional int64 creation_timestamp = 5;
  if (has_creation_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->creation_timestamp(), output);
  }
  
  // optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
  if (has_encrypted_private_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->encrypted_private_key(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Key::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .wallet.Key.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional bytes private_key = 2;
  if (has_private_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->private_key(), target);
  }
  
  // optional bytes public_key = 3;
  if (has_public_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->public_key(), target);
  }
  
  // optional string label = 4;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->label(), target);
  }
  
  // optional int64 creation_timestamp = 5;
  if (has_creation_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->creation_timestamp(), target);
  }
  
  // optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
  if (has_encrypted_private_key()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->encrypted_private_key(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Key::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .wallet.Key.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional bytes private_key = 2;
    if (has_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->private_key());
    }
    
    // optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
    if (has_encrypted_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->encrypted_private_key());
    }
    
    // optional bytes public_key = 3;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }
    
    // optional string label = 4;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }
    
    // optional int64 creation_timestamp = 5;
    if (has_creation_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->creation_timestamp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Key::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Key* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Key*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Key::MergeFrom(const Key& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_private_key()) {
      set_private_key(from.private_key());
    }
    if (from.has_encrypted_private_key()) {
      mutable_encrypted_private_key()->::wallet::EncryptedPrivateKey::MergeFrom(from.encrypted_private_key());
    }
    if (from.has_public_key()) {
      set_public_key(from.public_key());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_creation_timestamp()) {
      set_creation_timestamp(from.creation_timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Key::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Key::CopyFrom(const Key& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Key::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_encrypted_private_key()) {
    if (!this->encrypted_private_key().IsInitialized()) return false;
  }
  return true;
}

void Key::Swap(Key* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(private_key_, other->private_key_);
    std::swap(encrypted_private_key_, other->encrypted_private_key_);
    std::swap(public_key_, other->public_key_);
    std::swap(label_, other->label_);
    std::swap(creation_timestamp_, other->creation_timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Key::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Key_descriptor_;
  metadata.reflection = Key_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Script::kProgramFieldNumber;
const int Script::kCreationTimestampFieldNumber;
#endif  // !_MSC_VER

Script::Script()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Script::InitAsDefaultInstance() {
}

Script::Script(const Script& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Script::SharedCtor() {
  _cached_size_ = 0;
  program_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  creation_timestamp_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Script::~Script() {
  SharedDtor();
}

void Script::SharedDtor() {
  if (program_ != &::google::protobuf::internal::kEmptyString) {
    delete program_;
  }
  if (this != default_instance_) {
  }
}

void Script::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Script::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Script_descriptor_;
}

const Script& Script::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

Script* Script::default_instance_ = NULL;

Script* Script::New() const {
  return new Script;
}

void Script::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_program()) {
      if (program_ != &::google::protobuf::internal::kEmptyString) {
        program_->clear();
      }
    }
    creation_timestamp_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Script::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes program = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_program()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_creation_timestamp;
        break;
      }
      
      // required int64 creation_timestamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_creation_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &creation_timestamp_)));
          set_has_creation_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Script::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes program = 1;
  if (has_program()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->program(), output);
  }
  
  // required int64 creation_timestamp = 2;
  if (has_creation_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->creation_timestamp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Script::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes program = 1;
  if (has_program()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->program(), target);
  }
  
  // required int64 creation_timestamp = 2;
  if (has_creation_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->creation_timestamp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Script::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes program = 1;
    if (has_program()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->program());
    }
    
    // required int64 creation_timestamp = 2;
    if (has_creation_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->creation_timestamp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Script::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Script* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Script*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Script::MergeFrom(const Script& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_program()) {
      set_program(from.program());
    }
    if (from.has_creation_timestamp()) {
      set_creation_timestamp(from.creation_timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Script::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Script::CopyFrom(const Script& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Script::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Script::Swap(Script* other) {
  if (other != this) {
    std::swap(program_, other->program_);
    std::swap(creation_timestamp_, other->creation_timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Script::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Script_descriptor_;
  metadata.reflection = Script_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TransactionInput::kTransactionOutPointHashFieldNumber;
const int TransactionInput::kTransactionOutPointIndexFieldNumber;
const int TransactionInput::kScriptBytesFieldNumber;
const int TransactionInput::kSequenceFieldNumber;
#endif  // !_MSC_VER

TransactionInput::TransactionInput()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TransactionInput::InitAsDefaultInstance() {
}

TransactionInput::TransactionInput(const TransactionInput& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionInput::SharedCtor() {
  _cached_size_ = 0;
  transaction_out_point_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  transaction_out_point_index_ = 0u;
  script_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sequence_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionInput::~TransactionInput() {
  SharedDtor();
}

void TransactionInput::SharedDtor() {
  if (transaction_out_point_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete transaction_out_point_hash_;
  }
  if (script_bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete script_bytes_;
  }
  if (this != default_instance_) {
  }
}

void TransactionInput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionInput::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionInput_descriptor_;
}

const TransactionInput& TransactionInput::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

TransactionInput* TransactionInput::default_instance_ = NULL;

TransactionInput* TransactionInput::New() const {
  return new TransactionInput;
}

void TransactionInput::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_transaction_out_point_hash()) {
      if (transaction_out_point_hash_ != &::google::protobuf::internal::kEmptyString) {
        transaction_out_point_hash_->clear();
      }
    }
    transaction_out_point_index_ = 0u;
    if (has_script_bytes()) {
      if (script_bytes_ != &::google::protobuf::internal::kEmptyString) {
        script_bytes_->clear();
      }
    }
    sequence_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TransactionInput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes transaction_out_point_hash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_transaction_out_point_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_transaction_out_point_index;
        break;
      }
      
      // required uint32 transaction_out_point_index = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transaction_out_point_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &transaction_out_point_index_)));
          set_has_transaction_out_point_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_script_bytes;
        break;
      }
      
      // required bytes script_bytes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_script_bytes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_bytes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sequence;
        break;
      }
      
      // optional uint32 sequence = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionInput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes transaction_out_point_hash = 1;
  if (has_transaction_out_point_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->transaction_out_point_hash(), output);
  }
  
  // required uint32 transaction_out_point_index = 2;
  if (has_transaction_out_point_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->transaction_out_point_index(), output);
  }
  
  // required bytes script_bytes = 3;
  if (has_script_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->script_bytes(), output);
  }
  
  // optional uint32 sequence = 4;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->sequence(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TransactionInput::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes transaction_out_point_hash = 1;
  if (has_transaction_out_point_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->transaction_out_point_hash(), target);
  }
  
  // required uint32 transaction_out_point_index = 2;
  if (has_transaction_out_point_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->transaction_out_point_index(), target);
  }
  
  // required bytes script_bytes = 3;
  if (has_script_bytes()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->script_bytes(), target);
  }
  
  // optional uint32 sequence = 4;
  if (has_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->sequence(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TransactionInput::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes transaction_out_point_hash = 1;
    if (has_transaction_out_point_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->transaction_out_point_hash());
    }
    
    // required uint32 transaction_out_point_index = 2;
    if (has_transaction_out_point_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->transaction_out_point_index());
    }
    
    // required bytes script_bytes = 3;
    if (has_script_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script_bytes());
    }
    
    // optional uint32 sequence = 4;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionInput::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TransactionInput* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TransactionInput*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionInput::MergeFrom(const TransactionInput& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_transaction_out_point_hash()) {
      set_transaction_out_point_hash(from.transaction_out_point_hash());
    }
    if (from.has_transaction_out_point_index()) {
      set_transaction_out_point_index(from.transaction_out_point_index());
    }
    if (from.has_script_bytes()) {
      set_script_bytes(from.script_bytes());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TransactionInput::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionInput::CopyFrom(const TransactionInput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionInput::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void TransactionInput::Swap(TransactionInput* other) {
  if (other != this) {
    std::swap(transaction_out_point_hash_, other->transaction_out_point_hash_);
    std::swap(transaction_out_point_index_, other->transaction_out_point_index_);
    std::swap(script_bytes_, other->script_bytes_);
    std::swap(sequence_, other->sequence_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TransactionInput::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionInput_descriptor_;
  metadata.reflection = TransactionInput_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TransactionOutput::kValueFieldNumber;
const int TransactionOutput::kScriptBytesFieldNumber;
const int TransactionOutput::kSpentByTransactionHashFieldNumber;
const int TransactionOutput::kSpentByTransactionIndexFieldNumber;
#endif  // !_MSC_VER

TransactionOutput::TransactionOutput()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TransactionOutput::InitAsDefaultInstance() {
}

TransactionOutput::TransactionOutput(const TransactionOutput& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionOutput::SharedCtor() {
  _cached_size_ = 0;
  value_ = GOOGLE_LONGLONG(0);
  script_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  spent_by_transaction_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  spent_by_transaction_index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionOutput::~TransactionOutput() {
  SharedDtor();
}

void TransactionOutput::SharedDtor() {
  if (script_bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete script_bytes_;
  }
  if (spent_by_transaction_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete spent_by_transaction_hash_;
  }
  if (this != default_instance_) {
  }
}

void TransactionOutput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionOutput::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionOutput_descriptor_;
}

const TransactionOutput& TransactionOutput::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

TransactionOutput* TransactionOutput::default_instance_ = NULL;

TransactionOutput* TransactionOutput::New() const {
  return new TransactionOutput;
}

void TransactionOutput::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    value_ = GOOGLE_LONGLONG(0);
    if (has_script_bytes()) {
      if (script_bytes_ != &::google::protobuf::internal::kEmptyString) {
        script_bytes_->clear();
      }
    }
    if (has_spent_by_transaction_hash()) {
      if (spent_by_transaction_hash_ != &::google::protobuf::internal::kEmptyString) {
        spent_by_transaction_hash_->clear();
      }
    }
    spent_by_transaction_index_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TransactionOutput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_script_bytes;
        break;
      }
      
      // required bytes script_bytes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_script_bytes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_bytes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_spent_by_transaction_hash;
        break;
      }
      
      // optional bytes spent_by_transaction_hash = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spent_by_transaction_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_spent_by_transaction_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_spent_by_transaction_index;
        break;
      }
      
      // optional int32 spent_by_transaction_index = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_spent_by_transaction_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &spent_by_transaction_index_)));
          set_has_spent_by_transaction_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionOutput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->value(), output);
  }
  
  // required bytes script_bytes = 2;
  if (has_script_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->script_bytes(), output);
  }
  
  // optional bytes spent_by_transaction_hash = 3;
  if (has_spent_by_transaction_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->spent_by_transaction_hash(), output);
  }
  
  // optional int32 spent_by_transaction_index = 4;
  if (has_spent_by_transaction_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->spent_by_transaction_index(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TransactionOutput::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 value = 1;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->value(), target);
  }
  
  // required bytes script_bytes = 2;
  if (has_script_bytes()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->script_bytes(), target);
  }
  
  // optional bytes spent_by_transaction_hash = 3;
  if (has_spent_by_transaction_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->spent_by_transaction_hash(), target);
  }
  
  // optional int32 spent_by_transaction_index = 4;
  if (has_spent_by_transaction_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->spent_by_transaction_index(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TransactionOutput::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 value = 1;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->value());
    }
    
    // required bytes script_bytes = 2;
    if (has_script_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script_bytes());
    }
    
    // optional bytes spent_by_transaction_hash = 3;
    if (has_spent_by_transaction_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->spent_by_transaction_hash());
    }
    
    // optional int32 spent_by_transaction_index = 4;
    if (has_spent_by_transaction_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->spent_by_transaction_index());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionOutput::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TransactionOutput* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TransactionOutput*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionOutput::MergeFrom(const TransactionOutput& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_script_bytes()) {
      set_script_bytes(from.script_bytes());
    }
    if (from.has_spent_by_transaction_hash()) {
      set_spent_by_transaction_hash(from.spent_by_transaction_hash());
    }
    if (from.has_spent_by_transaction_index()) {
      set_spent_by_transaction_index(from.spent_by_transaction_index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TransactionOutput::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionOutput::CopyFrom(const TransactionOutput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionOutput::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void TransactionOutput::Swap(TransactionOutput* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(script_bytes_, other->script_bytes_);
    std::swap(spent_by_transaction_hash_, other->spent_by_transaction_hash_);
    std::swap(spent_by_transaction_index_, other->spent_by_transaction_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TransactionOutput::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionOutput_descriptor_;
  metadata.reflection = TransactionOutput_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* TransactionConfidence_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionConfidence_Type_descriptor_;
}
bool TransactionConfidence_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TransactionConfidence_Type TransactionConfidence::UNKNOWN;
const TransactionConfidence_Type TransactionConfidence::BUILDING;
const TransactionConfidence_Type TransactionConfidence::PENDING;
const TransactionConfidence_Type TransactionConfidence::NOT_IN_BEST_CHAIN;
const TransactionConfidence_Type TransactionConfidence::DEAD;
const TransactionConfidence_Type TransactionConfidence::Type_MIN;
const TransactionConfidence_Type TransactionConfidence::Type_MAX;
const int TransactionConfidence::Type_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* TransactionConfidence_Source_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionConfidence_Source_descriptor_;
}
bool TransactionConfidence_Source_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TransactionConfidence_Source TransactionConfidence::SOURCE_UNKNOWN;
const TransactionConfidence_Source TransactionConfidence::SOURCE_NETWORK;
const TransactionConfidence_Source TransactionConfidence::SOURCE_SELF;
const TransactionConfidence_Source TransactionConfidence::Source_MIN;
const TransactionConfidence_Source TransactionConfidence::Source_MAX;
const int TransactionConfidence::Source_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TransactionConfidence::kTypeFieldNumber;
const int TransactionConfidence::kAppearedAtHeightFieldNumber;
const int TransactionConfidence::kOverridingTransactionFieldNumber;
const int TransactionConfidence::kDepthFieldNumber;
const int TransactionConfidence::kWorkDoneFieldNumber;
const int TransactionConfidence::kBroadcastByFieldNumber;
const int TransactionConfidence::kSourceFieldNumber;
#endif  // !_MSC_VER

TransactionConfidence::TransactionConfidence()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TransactionConfidence::InitAsDefaultInstance() {
}

TransactionConfidence::TransactionConfidence(const TransactionConfidence& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionConfidence::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  appeared_at_height_ = 0;
  overriding_transaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  depth_ = 0;
  work_done_ = GOOGLE_LONGLONG(0);
  source_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionConfidence::~TransactionConfidence() {
  SharedDtor();
}

void TransactionConfidence::SharedDtor() {
  if (overriding_transaction_ != &::google::protobuf::internal::kEmptyString) {
    delete overriding_transaction_;
  }
  if (this != default_instance_) {
  }
}

void TransactionConfidence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionConfidence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionConfidence_descriptor_;
}

const TransactionConfidence& TransactionConfidence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

TransactionConfidence* TransactionConfidence::default_instance_ = NULL;

TransactionConfidence* TransactionConfidence::New() const {
  return new TransactionConfidence;
}

void TransactionConfidence::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    appeared_at_height_ = 0;
    if (has_overriding_transaction()) {
      if (overriding_transaction_ != &::google::protobuf::internal::kEmptyString) {
        overriding_transaction_->clear();
      }
    }
    depth_ = 0;
    work_done_ = GOOGLE_LONGLONG(0);
    source_ = 0;
  }
  broadcast_by_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TransactionConfidence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .wallet.TransactionConfidence.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wallet::TransactionConfidence_Type_IsValid(value)) {
            set_type(static_cast< ::wallet::TransactionConfidence_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_appeared_at_height;
        break;
      }
      
      // optional int32 appeared_at_height = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_appeared_at_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &appeared_at_height_)));
          set_has_appeared_at_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_overriding_transaction;
        break;
      }
      
      // optional bytes overriding_transaction = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_overriding_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_overriding_transaction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_depth;
        break;
      }
      
      // optional int32 depth = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_depth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &depth_)));
          set_has_depth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_work_done;
        break;
      }
      
      // optional int64 work_done = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_work_done:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &work_done_)));
          set_has_work_done();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_broadcast_by;
        break;
      }
      
      // repeated .wallet.PeerAddress broadcast_by = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_broadcast_by:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_broadcast_by()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_broadcast_by;
        if (input->ExpectTag(56)) goto parse_source;
        break;
      }
      
      // optional .wallet.TransactionConfidence.Source source = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_source:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wallet::TransactionConfidence_Source_IsValid(value)) {
            set_source(static_cast< ::wallet::TransactionConfidence_Source >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionConfidence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .wallet.TransactionConfidence.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional int32 appeared_at_height = 2;
  if (has_appeared_at_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->appeared_at_height(), output);
  }
  
  // optional bytes overriding_transaction = 3;
  if (has_overriding_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->overriding_transaction(), output);
  }
  
  // optional int32 depth = 4;
  if (has_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->depth(), output);
  }
  
  // optional int64 work_done = 5;
  if (has_work_done()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->work_done(), output);
  }
  
  // repeated .wallet.PeerAddress broadcast_by = 6;
  for (int i = 0; i < this->broadcast_by_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->broadcast_by(i), output);
  }
  
  // optional .wallet.TransactionConfidence.Source source = 7;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->source(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TransactionConfidence::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .wallet.TransactionConfidence.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional int32 appeared_at_height = 2;
  if (has_appeared_at_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->appeared_at_height(), target);
  }
  
  // optional bytes overriding_transaction = 3;
  if (has_overriding_transaction()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->overriding_transaction(), target);
  }
  
  // optional int32 depth = 4;
  if (has_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->depth(), target);
  }
  
  // optional int64 work_done = 5;
  if (has_work_done()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->work_done(), target);
  }
  
  // repeated .wallet.PeerAddress broadcast_by = 6;
  for (int i = 0; i < this->broadcast_by_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->broadcast_by(i), target);
  }
  
  // optional .wallet.TransactionConfidence.Source source = 7;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->source(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TransactionConfidence::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .wallet.TransactionConfidence.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional int32 appeared_at_height = 2;
    if (has_appeared_at_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->appeared_at_height());
    }
    
    // optional bytes overriding_transaction = 3;
    if (has_overriding_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->overriding_transaction());
    }
    
    // optional int32 depth = 4;
    if (has_depth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->depth());
    }
    
    // optional int64 work_done = 5;
    if (has_work_done()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->work_done());
    }
    
    // optional .wallet.TransactionConfidence.Source source = 7;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->source());
    }
    
  }
  // repeated .wallet.PeerAddress broadcast_by = 6;
  total_size += 1 * this->broadcast_by_size();
  for (int i = 0; i < this->broadcast_by_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->broadcast_by(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionConfidence::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TransactionConfidence* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TransactionConfidence*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionConfidence::MergeFrom(const TransactionConfidence& from) {
  GOOGLE_CHECK_NE(&from, this);
  broadcast_by_.MergeFrom(from.broadcast_by_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_appeared_at_height()) {
      set_appeared_at_height(from.appeared_at_height());
    }
    if (from.has_overriding_transaction()) {
      set_overriding_transaction(from.overriding_transaction());
    }
    if (from.has_depth()) {
      set_depth(from.depth());
    }
    if (from.has_work_done()) {
      set_work_done(from.work_done());
    }
    if (from.has_source()) {
      set_source(from.source());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TransactionConfidence::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionConfidence::CopyFrom(const TransactionConfidence& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionConfidence::IsInitialized() const {
  
  for (int i = 0; i < broadcast_by_size(); i++) {
    if (!this->broadcast_by(i).IsInitialized()) return false;
  }
  return true;
}

void TransactionConfidence::Swap(TransactionConfidence* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(appeared_at_height_, other->appeared_at_height_);
    std::swap(overriding_transaction_, other->overriding_transaction_);
    std::swap(depth_, other->depth_);
    std::swap(work_done_, other->work_done_);
    broadcast_by_.Swap(&other->broadcast_by_);
    std::swap(source_, other->source_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TransactionConfidence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionConfidence_descriptor_;
  metadata.reflection = TransactionConfidence_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Transaction_Pool_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Transaction_Pool_descriptor_;
}
bool Transaction_Pool_IsValid(int value) {
  switch(value) {
    case 2:
    case 4:
    case 5:
    case 10:
    case 16:
    case 18:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Transaction_Pool Transaction::UNSPENT;
const Transaction_Pool Transaction::SPENT;
const Transaction_Pool Transaction::INACTIVE;
const Transaction_Pool Transaction::DEAD;
const Transaction_Pool Transaction::PENDING;
const Transaction_Pool Transaction::PENDING_INACTIVE;
const Transaction_Pool Transaction::Pool_MIN;
const Transaction_Pool Transaction::Pool_MAX;
const int Transaction::Pool_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Transaction_Purpose_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Transaction_Purpose_descriptor_;
}
bool Transaction_Purpose_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Transaction_Purpose Transaction::UNKNOWN;
const Transaction_Purpose Transaction::USER_PAYMENT;
const Transaction_Purpose Transaction::KEY_ROTATION;
const Transaction_Purpose Transaction::Purpose_MIN;
const Transaction_Purpose Transaction::Purpose_MAX;
const int Transaction::Purpose_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Transaction::kVersionFieldNumber;
const int Transaction::kHashFieldNumber;
const int Transaction::kPoolFieldNumber;
const int Transaction::kLockTimeFieldNumber;
const int Transaction::kUpdatedAtFieldNumber;
const int Transaction::kTransactionInputFieldNumber;
const int Transaction::kTransactionOutputFieldNumber;
const int Transaction::kBlockHashFieldNumber;
const int Transaction::kBlockRelativityOffsetsFieldNumber;
const int Transaction::kConfidenceFieldNumber;
const int Transaction::kPurposeFieldNumber;
#endif  // !_MSC_VER

Transaction::Transaction()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Transaction::InitAsDefaultInstance() {
  confidence_ = const_cast< ::wallet::TransactionConfidence*>(&::wallet::TransactionConfidence::default_instance());
}

Transaction::Transaction(const Transaction& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Transaction::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pool_ = 4;
  lock_time_ = 0u;
  updated_at_ = GOOGLE_LONGLONG(0);
  confidence_ = NULL;
  purpose_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Transaction::~Transaction() {
  SharedDtor();
}

void Transaction::SharedDtor() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (this != default_instance_) {
    delete confidence_;
  }
}

void Transaction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Transaction::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Transaction_descriptor_;
}

const Transaction& Transaction::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

Transaction* Transaction::default_instance_ = NULL;

Transaction* Transaction::New() const {
  return new Transaction;
}

void Transaction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0;
    if (has_hash()) {
      if (hash_ != &::google::protobuf::internal::kEmptyString) {
        hash_->clear();
      }
    }
    pool_ = 4;
    lock_time_ = 0u;
    updated_at_ = GOOGLE_LONGLONG(0);
  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (has_confidence()) {
      if (confidence_ != NULL) confidence_->::wallet::TransactionConfidence::Clear();
    }
    purpose_ = 0;
  }
  transaction_input_.Clear();
  transaction_output_.Clear();
  block_hash_.Clear();
  block_relativity_offsets_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Transaction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hash;
        break;
      }
      
      // required bytes hash = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pool;
        break;
      }
      
      // optional .wallet.Transaction.Pool pool = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pool:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wallet::Transaction_Pool_IsValid(value)) {
            set_pool(static_cast< ::wallet::Transaction_Pool >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_lock_time;
        break;
      }
      
      // optional uint32 lock_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lock_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_time_)));
          set_has_lock_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_updated_at;
        break;
      }
      
      // optional int64 updated_at = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_updated_at:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &updated_at_)));
          set_has_updated_at();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_transaction_input;
        break;
      }
      
      // repeated .wallet.TransactionInput transaction_input = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transaction_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transaction_input()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_transaction_input;
        if (input->ExpectTag(58)) goto parse_transaction_output;
        break;
      }
      
      // repeated .wallet.TransactionOutput transaction_output = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transaction_output:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transaction_output()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_transaction_output;
        if (input->ExpectTag(66)) goto parse_block_hash;
        break;
      }
      
      // repeated bytes block_hash = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_block_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_block_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_block_hash;
        if (input->ExpectTag(74)) goto parse_confidence;
        break;
      }
      
      // optional .wallet.TransactionConfidence confidence = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_confidence:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_confidence()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_purpose;
        break;
      }
      
      // optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_purpose:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wallet::Transaction_Purpose_IsValid(value)) {
            set_purpose(static_cast< ::wallet::Transaction_Purpose >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_block_relativity_offsets;
        break;
      }
      
      // repeated int32 block_relativity_offsets = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_block_relativity_offsets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 88, input, this->mutable_block_relativity_offsets())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_block_relativity_offsets())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_block_relativity_offsets;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Transaction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }
  
  // required bytes hash = 2;
  if (has_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->hash(), output);
  }
  
  // optional .wallet.Transaction.Pool pool = 3;
  if (has_pool()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->pool(), output);
  }
  
  // optional uint32 lock_time = 4;
  if (has_lock_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->lock_time(), output);
  }
  
  // optional int64 updated_at = 5;
  if (has_updated_at()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->updated_at(), output);
  }
  
  // repeated .wallet.TransactionInput transaction_input = 6;
  for (int i = 0; i < this->transaction_input_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->transaction_input(i), output);
  }
  
  // repeated .wallet.TransactionOutput transaction_output = 7;
  for (int i = 0; i < this->transaction_output_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->transaction_output(i), output);
  }
  
  // repeated bytes block_hash = 8;
  for (int i = 0; i < this->block_hash_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->block_hash(i), output);
  }
  
  // optional .wallet.TransactionConfidence confidence = 9;
  if (has_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->confidence(), output);
  }
  
  // optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];
  if (has_purpose()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->purpose(), output);
  }
  
  // repeated int32 block_relativity_offsets = 11;
  for (int i = 0; i < this->block_relativity_offsets_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      11, this->block_relativity_offsets(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Transaction::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->version(), target);
  }
  
  // required bytes hash = 2;
  if (has_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->hash(), target);
  }
  
  // optional .wallet.Transaction.Pool pool = 3;
  if (has_pool()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->pool(), target);
  }
  
  // optional uint32 lock_time = 4;
  if (has_lock_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->lock_time(), target);
  }
  
  // optional int64 updated_at = 5;
  if (has_updated_at()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->updated_at(), target);
  }
  
  // repeated .wallet.TransactionInput transaction_input = 6;
  for (int i = 0; i < this->transaction_input_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->transaction_input(i), target);
  }
  
  // repeated .wallet.TransactionOutput transaction_output = 7;
  for (int i = 0; i < this->transaction_output_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->transaction_output(i), target);
  }
  
  // repeated bytes block_hash = 8;
  for (int i = 0; i < this->block_hash_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(8, this->block_hash(i), target);
  }
  
  // optional .wallet.TransactionConfidence confidence = 9;
  if (has_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->confidence(), target);
  }
  
  // optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];
  if (has_purpose()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->purpose(), target);
  }
  
  // repeated int32 block_relativity_offsets = 11;
  for (int i = 0; i < this->block_relativity_offsets_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(11, this->block_relativity_offsets(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Transaction::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }
    
    // required bytes hash = 2;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }
    
    // optional .wallet.Transaction.Pool pool = 3;
    if (has_pool()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->pool());
    }
    
    // optional uint32 lock_time = 4;
    if (has_lock_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock_time());
    }
    
    // optional int64 updated_at = 5;
    if (has_updated_at()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->updated_at());
    }
    
  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // optional .wallet.TransactionConfidence confidence = 9;
    if (has_confidence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->confidence());
    }
    
    // optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];
    if (has_purpose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->purpose());
    }
    
  }
  // repeated .wallet.TransactionInput transaction_input = 6;
  total_size += 1 * this->transaction_input_size();
  for (int i = 0; i < this->transaction_input_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->transaction_input(i));
  }
  
  // repeated .wallet.TransactionOutput transaction_output = 7;
  total_size += 1 * this->transaction_output_size();
  for (int i = 0; i < this->transaction_output_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->transaction_output(i));
  }
  
  // repeated bytes block_hash = 8;
  total_size += 1 * this->block_hash_size();
  for (int i = 0; i < this->block_hash_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->block_hash(i));
  }
  
  // repeated int32 block_relativity_offsets = 11;
  {
    int data_size = 0;
    for (int i = 0; i < this->block_relativity_offsets_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->block_relativity_offsets(i));
    }
    total_size += 1 * this->block_relativity_offsets_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transaction::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Transaction* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Transaction*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Transaction::MergeFrom(const Transaction& from) {
  GOOGLE_CHECK_NE(&from, this);
  transaction_input_.MergeFrom(from.transaction_input_);
  transaction_output_.MergeFrom(from.transaction_output_);
  block_hash_.MergeFrom(from.block_hash_);
  block_relativity_offsets_.MergeFrom(from.block_relativity_offsets_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_hash()) {
      set_hash(from.hash());
    }
    if (from.has_pool()) {
      set_pool(from.pool());
    }
    if (from.has_lock_time()) {
      set_lock_time(from.lock_time());
    }
    if (from.has_updated_at()) {
      set_updated_at(from.updated_at());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_confidence()) {
      mutable_confidence()->::wallet::TransactionConfidence::MergeFrom(from.confidence());
    }
    if (from.has_purpose()) {
      set_purpose(from.purpose());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Transaction::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Transaction::CopyFrom(const Transaction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transaction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < transaction_input_size(); i++) {
    if (!this->transaction_input(i).IsInitialized()) return false;
  }
  for (int i = 0; i < transaction_output_size(); i++) {
    if (!this->transaction_output(i).IsInitialized()) return false;
  }
  if (has_confidence()) {
    if (!this->confidence().IsInitialized()) return false;
  }
  return true;
}

void Transaction::Swap(Transaction* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(hash_, other->hash_);
    std::swap(pool_, other->pool_);
    std::swap(lock_time_, other->lock_time_);
    std::swap(updated_at_, other->updated_at_);
    transaction_input_.Swap(&other->transaction_input_);
    transaction_output_.Swap(&other->transaction_output_);
    block_hash_.Swap(&other->block_hash_);
    block_relativity_offsets_.Swap(&other->block_relativity_offsets_);
    std::swap(confidence_, other->confidence_);
    std::swap(purpose_, other->purpose_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Transaction::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Transaction_descriptor_;
  metadata.reflection = Transaction_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ScryptParameters::kSaltFieldNumber;
const int ScryptParameters::kNFieldNumber;
const int ScryptParameters::kRFieldNumber;
const int ScryptParameters::kPFieldNumber;
#endif  // !_MSC_VER

ScryptParameters::ScryptParameters()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ScryptParameters::InitAsDefaultInstance() {
}

ScryptParameters::ScryptParameters(const ScryptParameters& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ScryptParameters::SharedCtor() {
  _cached_size_ = 0;
  salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  n_ = GOOGLE_LONGLONG(16384);
  r_ = 8;
  p_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScryptParameters::~ScryptParameters() {
  SharedDtor();
}

void ScryptParameters::SharedDtor() {
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    delete salt_;
  }
  if (this != default_instance_) {
  }
}

void ScryptParameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScryptParameters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScryptParameters_descriptor_;
}

const ScryptParameters& ScryptParameters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

ScryptParameters* ScryptParameters::default_instance_ = NULL;

ScryptParameters* ScryptParameters::New() const {
  return new ScryptParameters;
}

void ScryptParameters::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_salt()) {
      if (salt_ != &::google::protobuf::internal::kEmptyString) {
        salt_->clear();
      }
    }
    n_ = GOOGLE_LONGLONG(16384);
    r_ = 8;
    p_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ScryptParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes salt = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_salt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_n;
        break;
      }
      
      // optional int64 n = 2 [default = 16384];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &n_)));
          set_has_n();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_r;
        break;
      }
      
      // optional int32 r = 3 [default = 8];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_r:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &r_)));
          set_has_r();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_p;
        break;
      }
      
      // optional int32 p = 4 [default = 1];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_p:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &p_)));
          set_has_p();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ScryptParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes salt = 1;
  if (has_salt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->salt(), output);
  }
  
  // optional int64 n = 2 [default = 16384];
  if (has_n()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->n(), output);
  }
  
  // optional int32 r = 3 [default = 8];
  if (has_r()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->r(), output);
  }
  
  // optional int32 p = 4 [default = 1];
  if (has_p()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->p(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ScryptParameters::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes salt = 1;
  if (has_salt()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->salt(), target);
  }
  
  // optional int64 n = 2 [default = 16384];
  if (has_n()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->n(), target);
  }
  
  // optional int32 r = 3 [default = 8];
  if (has_r()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->r(), target);
  }
  
  // optional int32 p = 4 [default = 1];
  if (has_p()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->p(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ScryptParameters::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes salt = 1;
    if (has_salt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->salt());
    }
    
    // optional int64 n = 2 [default = 16384];
    if (has_n()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->n());
    }
    
    // optional int32 r = 3 [default = 8];
    if (has_r()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->r());
    }
    
    // optional int32 p = 4 [default = 1];
    if (has_p()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->p());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScryptParameters::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ScryptParameters* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ScryptParameters*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScryptParameters::MergeFrom(const ScryptParameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_salt()) {
      set_salt(from.salt());
    }
    if (from.has_n()) {
      set_n(from.n());
    }
    if (from.has_r()) {
      set_r(from.r());
    }
    if (from.has_p()) {
      set_p(from.p());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ScryptParameters::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScryptParameters::CopyFrom(const ScryptParameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScryptParameters::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void ScryptParameters::Swap(ScryptParameters* other) {
  if (other != this) {
    std::swap(salt_, other->salt_);
    std::swap(n_, other->n_);
    std::swap(r_, other->r_);
    std::swap(p_, other->p_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ScryptParameters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScryptParameters_descriptor_;
  metadata.reflection = ScryptParameters_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Extension::kIdFieldNumber;
const int Extension::kDataFieldNumber;
const int Extension::kMandatoryFieldNumber;
#endif  // !_MSC_VER

Extension::Extension()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Extension::InitAsDefaultInstance() {
}

Extension::Extension(const Extension& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Extension::SharedCtor() {
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mandatory_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Extension::~Extension() {
  SharedDtor();
}

void Extension::SharedDtor() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void Extension::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Extension::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Extension_descriptor_;
}

const Extension& Extension::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

Extension* Extension::default_instance_ = NULL;

Extension* Extension::New() const {
  return new Extension;
}

void Extension::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::kEmptyString) {
        id_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
    mandatory_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Extension::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }
      
      // required bytes data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mandatory;
        break;
      }
      
      // required bool mandatory = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mandatory:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mandatory_)));
          set_has_mandatory();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Extension::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->id(), output);
  }
  
  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->data(), output);
  }
  
  // required bool mandatory = 3;
  if (has_mandatory()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->mandatory(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Extension::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }
  
  // required bytes data = 2;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->data(), target);
  }
  
  // required bool mandatory = 3;
  if (has_mandatory()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->mandatory(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Extension::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }
    
    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }
    
    // required bool mandatory = 3;
    if (has_mandatory()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Extension::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Extension* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Extension*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Extension::MergeFrom(const Extension& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
    if (from.has_mandatory()) {
      set_mandatory(from.mandatory());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Extension::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Extension::CopyFrom(const Extension& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Extension::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Extension::Swap(Extension* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(data_, other->data_);
    std::swap(mandatory_, other->mandatory_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Extension::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Extension_descriptor_;
  metadata.reflection = Extension_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Wallet_EncryptionType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Wallet_EncryptionType_descriptor_;
}
bool Wallet_EncryptionType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Wallet_EncryptionType Wallet::UNENCRYPTED;
const Wallet_EncryptionType Wallet::ENCRYPTED_SCRYPT_AES;
const Wallet_EncryptionType Wallet::EncryptionType_MIN;
const Wallet_EncryptionType Wallet::EncryptionType_MAX;
const int Wallet::EncryptionType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Wallet::kNetworkIdentifierFieldNumber;
const int Wallet::kLastSeenBlockHashFieldNumber;
const int Wallet::kLastSeenBlockHeightFieldNumber;
const int Wallet::kLastSeenBlockTimeSecsFieldNumber;
const int Wallet::kKeyFieldNumber;
const int Wallet::kTransactionFieldNumber;
const int Wallet::kWatchedScriptFieldNumber;
const int Wallet::kEncryptionTypeFieldNumber;
const int Wallet::kEncryptionParametersFieldNumber;
const int Wallet::kVersionFieldNumber;
const int Wallet::kExtensionFieldNumber;
const int Wallet::kDescriptionFieldNumber;
const int Wallet::kKeyRotationTimeFieldNumber;
#endif  // !_MSC_VER

Wallet::Wallet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Wallet::InitAsDefaultInstance() {
  encryption_parameters_ = const_cast< ::wallet::ScryptParameters*>(&::wallet::ScryptParameters::default_instance());
}

Wallet::Wallet(const Wallet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Wallet::SharedCtor() {
  _cached_size_ = 0;
  network_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  last_seen_block_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  last_seen_block_height_ = 0u;
  last_seen_block_time_secs_ = GOOGLE_LONGLONG(0);
  encryption_type_ = 1;
  encryption_parameters_ = NULL;
  version_ = 0;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_rotation_time_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Wallet::~Wallet() {
  SharedDtor();
}

void Wallet::SharedDtor() {
  if (network_identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete network_identifier_;
  }
  if (last_seen_block_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete last_seen_block_hash_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (this != default_instance_) {
    delete encryption_parameters_;
  }
}

void Wallet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Wallet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Wallet_descriptor_;
}

const Wallet& Wallet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_multibit_2eproto();  return *default_instance_;
}

Wallet* Wallet::default_instance_ = NULL;

Wallet* Wallet::New() const {
  return new Wallet;
}

void Wallet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_network_identifier()) {
      if (network_identifier_ != &::google::protobuf::internal::kEmptyString) {
        network_identifier_->clear();
      }
    }
    if (has_last_seen_block_hash()) {
      if (last_seen_block_hash_ != &::google::protobuf::internal::kEmptyString) {
        last_seen_block_hash_->clear();
      }
    }
    last_seen_block_height_ = 0u;
    last_seen_block_time_secs_ = GOOGLE_LONGLONG(0);
    encryption_type_ = 1;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_encryption_parameters()) {
      if (encryption_parameters_ != NULL) encryption_parameters_->::wallet::ScryptParameters::Clear();
    }
    version_ = 0;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    key_rotation_time_ = GOOGLE_ULONGLONG(0);
  }
  key_.Clear();
  transaction_.Clear();
  watched_script_.Clear();
  extension_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Wallet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string network_identifier = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_network_identifier()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->network_identifier().data(), this->network_identifier().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_last_seen_block_hash;
        break;
      }
      
      // optional bytes last_seen_block_hash = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_last_seen_block_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_last_seen_block_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key;
        break;
      }
      
      // repeated .wallet.Key key = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_key;
        if (input->ExpectTag(34)) goto parse_transaction;
        break;
      }
      
      // repeated .wallet.Transaction transaction = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transaction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_transaction;
        if (input->ExpectTag(40)) goto parse_encryption_type;
        break;
      }
      
      // optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encryption_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::wallet::Wallet_EncryptionType_IsValid(value)) {
            set_encryption_type(static_cast< ::wallet::Wallet_EncryptionType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_encryption_parameters;
        break;
      }
      
      // optional .wallet.ScryptParameters encryption_parameters = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encryption_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_encryption_parameters()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_version;
        break;
      }
      
      // optional int32 version = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_extension;
        break;
      }
      
      // repeated .wallet.Extension extension = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_extension:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_extension()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_extension;
        if (input->ExpectTag(90)) goto parse_description;
        break;
      }
      
      // optional string description = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_last_seen_block_height;
        break;
      }
      
      // optional uint32 last_seen_block_height = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_last_seen_block_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &last_seen_block_height_)));
          set_has_last_seen_block_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_key_rotation_time;
        break;
      }
      
      // optional uint64 key_rotation_time = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_key_rotation_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &key_rotation_time_)));
          set_has_key_rotation_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_last_seen_block_time_secs;
        break;
      }
      
      // optional int64 last_seen_block_time_secs = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_last_seen_block_time_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &last_seen_block_time_secs_)));
          set_has_last_seen_block_time_secs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_watched_script;
        break;
      }
      
      // repeated .wallet.Script watched_script = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_watched_script:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_watched_script()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_watched_script;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Wallet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string network_identifier = 1;
  if (has_network_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->network_identifier().data(), this->network_identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->network_identifier(), output);
  }
  
  // optional bytes last_seen_block_hash = 2;
  if (has_last_seen_block_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->last_seen_block_hash(), output);
  }
  
  // repeated .wallet.Key key = 3;
  for (int i = 0; i < this->key_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->key(i), output);
  }
  
  // repeated .wallet.Transaction transaction = 4;
  for (int i = 0; i < this->transaction_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->transaction(i), output);
  }
  
  // optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];
  if (has_encryption_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->encryption_type(), output);
  }
  
  // optional .wallet.ScryptParameters encryption_parameters = 6;
  if (has_encryption_parameters()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->encryption_parameters(), output);
  }
  
  // optional int32 version = 7;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->version(), output);
  }
  
  // repeated .wallet.Extension extension = 10;
  for (int i = 0; i < this->extension_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->extension(i), output);
  }
  
  // optional string description = 11;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->description(), output);
  }
  
  // optional uint32 last_seen_block_height = 12;
  if (has_last_seen_block_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->last_seen_block_height(), output);
  }
  
  // optional uint64 key_rotation_time = 13;
  if (has_key_rotation_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->key_rotation_time(), output);
  }
  
  // optional int64 last_seen_block_time_secs = 14;
  if (has_last_seen_block_time_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->last_seen_block_time_secs(), output);
  }
  
  // repeated .wallet.Script watched_script = 15;
  for (int i = 0; i < this->watched_script_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->watched_script(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Wallet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string network_identifier = 1;
  if (has_network_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->network_identifier().data(), this->network_identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->network_identifier(), target);
  }
  
  // optional bytes last_seen_block_hash = 2;
  if (has_last_seen_block_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->last_seen_block_hash(), target);
  }
  
  // repeated .wallet.Key key = 3;
  for (int i = 0; i < this->key_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->key(i), target);
  }
  
  // repeated .wallet.Transaction transaction = 4;
  for (int i = 0; i < this->transaction_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->transaction(i), target);
  }
  
  // optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];
  if (has_encryption_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->encryption_type(), target);
  }
  
  // optional .wallet.ScryptParameters encryption_parameters = 6;
  if (has_encryption_parameters()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->encryption_parameters(), target);
  }
  
  // optional int32 version = 7;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->version(), target);
  }
  
  // repeated .wallet.Extension extension = 10;
  for (int i = 0; i < this->extension_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->extension(i), target);
  }
  
  // optional string description = 11;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->description(), target);
  }
  
  // optional uint32 last_seen_block_height = 12;
  if (has_last_seen_block_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->last_seen_block_height(), target);
  }
  
  // optional uint64 key_rotation_time = 13;
  if (has_key_rotation_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(13, this->key_rotation_time(), target);
  }
  
  // optional int64 last_seen_block_time_secs = 14;
  if (has_last_seen_block_time_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->last_seen_block_time_secs(), target);
  }
  
  // repeated .wallet.Script watched_script = 15;
  for (int i = 0; i < this->watched_script_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->watched_script(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Wallet::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string network_identifier = 1;
    if (has_network_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->network_identifier());
    }
    
    // optional bytes last_seen_block_hash = 2;
    if (has_last_seen_block_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->last_seen_block_hash());
    }
    
    // optional uint32 last_seen_block_height = 12;
    if (has_last_seen_block_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->last_seen_block_height());
    }
    
    // optional int64 last_seen_block_time_secs = 14;
    if (has_last_seen_block_time_secs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->last_seen_block_time_secs());
    }
    
    // optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];
    if (has_encryption_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->encryption_type());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .wallet.ScryptParameters encryption_parameters = 6;
    if (has_encryption_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->encryption_parameters());
    }
    
    // optional int32 version = 7;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }
    
    // optional string description = 11;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // optional uint64 key_rotation_time = 13;
    if (has_key_rotation_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->key_rotation_time());
    }
    
  }
  // repeated .wallet.Key key = 3;
  total_size += 1 * this->key_size();
  for (int i = 0; i < this->key_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->key(i));
  }
  
  // repeated .wallet.Transaction transaction = 4;
  total_size += 1 * this->transaction_size();
  for (int i = 0; i < this->transaction_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->transaction(i));
  }
  
  // repeated .wallet.Script watched_script = 15;
  total_size += 1 * this->watched_script_size();
  for (int i = 0; i < this->watched_script_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->watched_script(i));
  }
  
  // repeated .wallet.Extension extension = 10;
  total_size += 1 * this->extension_size();
  for (int i = 0; i < this->extension_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->extension(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Wallet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Wallet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Wallet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Wallet::MergeFrom(const Wallet& from) {
  GOOGLE_CHECK_NE(&from, this);
  key_.MergeFrom(from.key_);
  transaction_.MergeFrom(from.transaction_);
  watched_script_.MergeFrom(from.watched_script_);
  extension_.MergeFrom(from.extension_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_network_identifier()) {
      set_network_identifier(from.network_identifier());
    }
    if (from.has_last_seen_block_hash()) {
      set_last_seen_block_hash(from.last_seen_block_hash());
    }
    if (from.has_last_seen_block_height()) {
      set_last_seen_block_height(from.last_seen_block_height());
    }
    if (from.has_last_seen_block_time_secs()) {
      set_last_seen_block_time_secs(from.last_seen_block_time_secs());
    }
    if (from.has_encryption_type()) {
      set_encryption_type(from.encryption_type());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_encryption_parameters()) {
      mutable_encryption_parameters()->::wallet::ScryptParameters::MergeFrom(from.encryption_parameters());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_key_rotation_time()) {
      set_key_rotation_time(from.key_rotation_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Wallet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Wallet::CopyFrom(const Wallet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Wallet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < key_size(); i++) {
    if (!this->key(i).IsInitialized()) return false;
  }
  for (int i = 0; i < transaction_size(); i++) {
    if (!this->transaction(i).IsInitialized()) return false;
  }
  for (int i = 0; i < watched_script_size(); i++) {
    if (!this->watched_script(i).IsInitialized()) return false;
  }
  if (has_encryption_parameters()) {
    if (!this->encryption_parameters().IsInitialized()) return false;
  }
  for (int i = 0; i < extension_size(); i++) {
    if (!this->extension(i).IsInitialized()) return false;
  }
  return true;
}

void Wallet::Swap(Wallet* other) {
  if (other != this) {
    std::swap(network_identifier_, other->network_identifier_);
    std::swap(last_seen_block_hash_, other->last_seen_block_hash_);
    std::swap(last_seen_block_height_, other->last_seen_block_height_);
    std::swap(last_seen_block_time_secs_, other->last_seen_block_time_secs_);
    key_.Swap(&other->key_);
    transaction_.Swap(&other->transaction_);
    watched_script_.Swap(&other->watched_script_);
    std::swap(encryption_type_, other->encryption_type_);
    std::swap(encryption_parameters_, other->encryption_parameters_);
    std::swap(version_, other->version_);
    extension_.Swap(&other->extension_);
    std::swap(description_, other->description_);
    std::swap(key_rotation_time_, other->key_rotation_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Wallet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Wallet_descriptor_;
  metadata.reflection = Wallet_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace wallet

// @@protoc_insertion_point(global_scope)
