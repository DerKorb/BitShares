// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: multibit.proto

#ifndef PROTOBUF_multibit_2eproto__INCLUDED
#define PROTOBUF_multibit_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace wallet {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_multibit_2eproto();
void protobuf_AssignDesc_multibit_2eproto();
void protobuf_ShutdownFile_multibit_2eproto();

class PeerAddress;
class EncryptedPrivateKey;
class Key;
class Script;
class TransactionInput;
class TransactionOutput;
class TransactionConfidence;
class Transaction;
class ScryptParameters;
class Extension;
class Wallet;

enum Key_Type {
  Key_Type_ORIGINAL = 1,
  Key_Type_ENCRYPTED_SCRYPT_AES = 2
};
bool Key_Type_IsValid(int value);
const Key_Type Key_Type_Type_MIN = Key_Type_ORIGINAL;
const Key_Type Key_Type_Type_MAX = Key_Type_ENCRYPTED_SCRYPT_AES;
const int Key_Type_Type_ARRAYSIZE = Key_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Key_Type_descriptor();
inline const ::std::string& Key_Type_Name(Key_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Key_Type_descriptor(), value);
}
inline bool Key_Type_Parse(
    const ::std::string& name, Key_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Key_Type>(
    Key_Type_descriptor(), name, value);
}
enum TransactionConfidence_Type {
  TransactionConfidence_Type_UNKNOWN = 0,
  TransactionConfidence_Type_BUILDING = 1,
  TransactionConfidence_Type_PENDING = 2,
  TransactionConfidence_Type_NOT_IN_BEST_CHAIN = 3,
  TransactionConfidence_Type_DEAD = 4
};
bool TransactionConfidence_Type_IsValid(int value);
const TransactionConfidence_Type TransactionConfidence_Type_Type_MIN = TransactionConfidence_Type_UNKNOWN;
const TransactionConfidence_Type TransactionConfidence_Type_Type_MAX = TransactionConfidence_Type_DEAD;
const int TransactionConfidence_Type_Type_ARRAYSIZE = TransactionConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransactionConfidence_Type_descriptor();
inline const ::std::string& TransactionConfidence_Type_Name(TransactionConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransactionConfidence_Type_descriptor(), value);
}
inline bool TransactionConfidence_Type_Parse(
    const ::std::string& name, TransactionConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransactionConfidence_Type>(
    TransactionConfidence_Type_descriptor(), name, value);
}
enum TransactionConfidence_Source {
  TransactionConfidence_Source_SOURCE_UNKNOWN = 0,
  TransactionConfidence_Source_SOURCE_NETWORK = 1,
  TransactionConfidence_Source_SOURCE_SELF = 2
};
bool TransactionConfidence_Source_IsValid(int value);
const TransactionConfidence_Source TransactionConfidence_Source_Source_MIN = TransactionConfidence_Source_SOURCE_UNKNOWN;
const TransactionConfidence_Source TransactionConfidence_Source_Source_MAX = TransactionConfidence_Source_SOURCE_SELF;
const int TransactionConfidence_Source_Source_ARRAYSIZE = TransactionConfidence_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransactionConfidence_Source_descriptor();
inline const ::std::string& TransactionConfidence_Source_Name(TransactionConfidence_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransactionConfidence_Source_descriptor(), value);
}
inline bool TransactionConfidence_Source_Parse(
    const ::std::string& name, TransactionConfidence_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransactionConfidence_Source>(
    TransactionConfidence_Source_descriptor(), name, value);
}
enum Transaction_Pool {
  Transaction_Pool_UNSPENT = 4,
  Transaction_Pool_SPENT = 5,
  Transaction_Pool_INACTIVE = 2,
  Transaction_Pool_DEAD = 10,
  Transaction_Pool_PENDING = 16,
  Transaction_Pool_PENDING_INACTIVE = 18
};
bool Transaction_Pool_IsValid(int value);
const Transaction_Pool Transaction_Pool_Pool_MIN = Transaction_Pool_INACTIVE;
const Transaction_Pool Transaction_Pool_Pool_MAX = Transaction_Pool_PENDING_INACTIVE;
const int Transaction_Pool_Pool_ARRAYSIZE = Transaction_Pool_Pool_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Pool_descriptor();
inline const ::std::string& Transaction_Pool_Name(Transaction_Pool value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Pool_descriptor(), value);
}
inline bool Transaction_Pool_Parse(
    const ::std::string& name, Transaction_Pool* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Pool>(
    Transaction_Pool_descriptor(), name, value);
}
enum Transaction_Purpose {
  Transaction_Purpose_UNKNOWN = 0,
  Transaction_Purpose_USER_PAYMENT = 1,
  Transaction_Purpose_KEY_ROTATION = 2
};
bool Transaction_Purpose_IsValid(int value);
const Transaction_Purpose Transaction_Purpose_Purpose_MIN = Transaction_Purpose_UNKNOWN;
const Transaction_Purpose Transaction_Purpose_Purpose_MAX = Transaction_Purpose_KEY_ROTATION;
const int Transaction_Purpose_Purpose_ARRAYSIZE = Transaction_Purpose_Purpose_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Purpose_descriptor();
inline const ::std::string& Transaction_Purpose_Name(Transaction_Purpose value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Purpose_descriptor(), value);
}
inline bool Transaction_Purpose_Parse(
    const ::std::string& name, Transaction_Purpose* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Purpose>(
    Transaction_Purpose_descriptor(), name, value);
}
enum Wallet_EncryptionType {
  Wallet_EncryptionType_UNENCRYPTED = 1,
  Wallet_EncryptionType_ENCRYPTED_SCRYPT_AES = 2
};
bool Wallet_EncryptionType_IsValid(int value);
const Wallet_EncryptionType Wallet_EncryptionType_EncryptionType_MIN = Wallet_EncryptionType_UNENCRYPTED;
const Wallet_EncryptionType Wallet_EncryptionType_EncryptionType_MAX = Wallet_EncryptionType_ENCRYPTED_SCRYPT_AES;
const int Wallet_EncryptionType_EncryptionType_ARRAYSIZE = Wallet_EncryptionType_EncryptionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Wallet_EncryptionType_descriptor();
inline const ::std::string& Wallet_EncryptionType_Name(Wallet_EncryptionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Wallet_EncryptionType_descriptor(), value);
}
inline bool Wallet_EncryptionType_Parse(
    const ::std::string& name, Wallet_EncryptionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Wallet_EncryptionType>(
    Wallet_EncryptionType_descriptor(), name, value);
}
// ===================================================================

class PeerAddress : public ::google::protobuf::Message {
 public:
  PeerAddress();
  virtual ~PeerAddress();
  
  PeerAddress(const PeerAddress& from);
  
  inline PeerAddress& operator=(const PeerAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerAddress& default_instance();
  
  void Swap(PeerAddress* other);
  
  // implements Message ----------------------------------------------
  
  PeerAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerAddress& from);
  void MergeFrom(const PeerAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes ip_address = 1;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 1;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const void* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  
  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // required uint64 services = 3;
  inline bool has_services() const;
  inline void clear_services();
  static const int kServicesFieldNumber = 3;
  inline ::google::protobuf::uint64 services() const;
  inline void set_services(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:wallet.PeerAddress)
 private:
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_services();
  inline void clear_has_services();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_address_;
  ::google::protobuf::uint64 services_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static PeerAddress* default_instance_;
};
// -------------------------------------------------------------------

class EncryptedPrivateKey : public ::google::protobuf::Message {
 public:
  EncryptedPrivateKey();
  virtual ~EncryptedPrivateKey();
  
  EncryptedPrivateKey(const EncryptedPrivateKey& from);
  
  inline EncryptedPrivateKey& operator=(const EncryptedPrivateKey& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptedPrivateKey& default_instance();
  
  void Swap(EncryptedPrivateKey* other);
  
  // implements Message ----------------------------------------------
  
  EncryptedPrivateKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncryptedPrivateKey& from);
  void MergeFrom(const EncryptedPrivateKey& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes initialisation_vector = 1;
  inline bool has_initialisation_vector() const;
  inline void clear_initialisation_vector();
  static const int kInitialisationVectorFieldNumber = 1;
  inline const ::std::string& initialisation_vector() const;
  inline void set_initialisation_vector(const ::std::string& value);
  inline void set_initialisation_vector(const char* value);
  inline void set_initialisation_vector(const void* value, size_t size);
  inline ::std::string* mutable_initialisation_vector();
  inline ::std::string* release_initialisation_vector();
  
  // required bytes encrypted_private_key = 2;
  inline bool has_encrypted_private_key() const;
  inline void clear_encrypted_private_key();
  static const int kEncryptedPrivateKeyFieldNumber = 2;
  inline const ::std::string& encrypted_private_key() const;
  inline void set_encrypted_private_key(const ::std::string& value);
  inline void set_encrypted_private_key(const char* value);
  inline void set_encrypted_private_key(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_private_key();
  inline ::std::string* release_encrypted_private_key();
  
  // @@protoc_insertion_point(class_scope:wallet.EncryptedPrivateKey)
 private:
  inline void set_has_initialisation_vector();
  inline void clear_has_initialisation_vector();
  inline void set_has_encrypted_private_key();
  inline void clear_has_encrypted_private_key();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* initialisation_vector_;
  ::std::string* encrypted_private_key_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static EncryptedPrivateKey* default_instance_;
};
// -------------------------------------------------------------------

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();
  
  Key(const Key& from);
  
  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();
  
  void Swap(Key* other);
  
  // implements Message ----------------------------------------------
  
  Key* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Key_Type Type;
  static const Type ORIGINAL = Key_Type_ORIGINAL;
  static const Type ENCRYPTED_SCRYPT_AES = Key_Type_ENCRYPTED_SCRYPT_AES;
  static inline bool Type_IsValid(int value) {
    return Key_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Key_Type_Type_MIN;
  static const Type Type_MAX =
    Key_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Key_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Key_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Key_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Key_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .wallet.Key.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::wallet::Key_Type type() const;
  inline void set_type(::wallet::Key_Type value);
  
  // optional bytes private_key = 2;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 2;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  
  // optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
  inline bool has_encrypted_private_key() const;
  inline void clear_encrypted_private_key();
  static const int kEncryptedPrivateKeyFieldNumber = 6;
  inline const ::wallet::EncryptedPrivateKey& encrypted_private_key() const;
  inline ::wallet::EncryptedPrivateKey* mutable_encrypted_private_key();
  inline ::wallet::EncryptedPrivateKey* release_encrypted_private_key();
  
  // optional bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  
  // optional string label = 4;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 4;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  
  // optional int64 creation_timestamp = 5;
  inline bool has_creation_timestamp() const;
  inline void clear_creation_timestamp();
  static const int kCreationTimestampFieldNumber = 5;
  inline ::google::protobuf::int64 creation_timestamp() const;
  inline void set_creation_timestamp(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:wallet.Key)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_private_key();
  inline void clear_has_private_key();
  inline void set_has_encrypted_private_key();
  inline void clear_has_encrypted_private_key();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_creation_timestamp();
  inline void clear_has_creation_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* private_key_;
  ::wallet::EncryptedPrivateKey* encrypted_private_key_;
  ::std::string* public_key_;
  ::std::string* label_;
  ::google::protobuf::int64 creation_timestamp_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// -------------------------------------------------------------------

class Script : public ::google::protobuf::Message {
 public:
  Script();
  virtual ~Script();
  
  Script(const Script& from);
  
  inline Script& operator=(const Script& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Script& default_instance();
  
  void Swap(Script* other);
  
  // implements Message ----------------------------------------------
  
  Script* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Script& from);
  void MergeFrom(const Script& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes program = 1;
  inline bool has_program() const;
  inline void clear_program();
  static const int kProgramFieldNumber = 1;
  inline const ::std::string& program() const;
  inline void set_program(const ::std::string& value);
  inline void set_program(const char* value);
  inline void set_program(const void* value, size_t size);
  inline ::std::string* mutable_program();
  inline ::std::string* release_program();
  
  // required int64 creation_timestamp = 2;
  inline bool has_creation_timestamp() const;
  inline void clear_creation_timestamp();
  static const int kCreationTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 creation_timestamp() const;
  inline void set_creation_timestamp(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:wallet.Script)
 private:
  inline void set_has_program();
  inline void clear_has_program();
  inline void set_has_creation_timestamp();
  inline void clear_has_creation_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* program_;
  ::google::protobuf::int64 creation_timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static Script* default_instance_;
};
// -------------------------------------------------------------------

class TransactionInput : public ::google::protobuf::Message {
 public:
  TransactionInput();
  virtual ~TransactionInput();
  
  TransactionInput(const TransactionInput& from);
  
  inline TransactionInput& operator=(const TransactionInput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionInput& default_instance();
  
  void Swap(TransactionInput* other);
  
  // implements Message ----------------------------------------------
  
  TransactionInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionInput& from);
  void MergeFrom(const TransactionInput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes transaction_out_point_hash = 1;
  inline bool has_transaction_out_point_hash() const;
  inline void clear_transaction_out_point_hash();
  static const int kTransactionOutPointHashFieldNumber = 1;
  inline const ::std::string& transaction_out_point_hash() const;
  inline void set_transaction_out_point_hash(const ::std::string& value);
  inline void set_transaction_out_point_hash(const char* value);
  inline void set_transaction_out_point_hash(const void* value, size_t size);
  inline ::std::string* mutable_transaction_out_point_hash();
  inline ::std::string* release_transaction_out_point_hash();
  
  // required uint32 transaction_out_point_index = 2;
  inline bool has_transaction_out_point_index() const;
  inline void clear_transaction_out_point_index();
  static const int kTransactionOutPointIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 transaction_out_point_index() const;
  inline void set_transaction_out_point_index(::google::protobuf::uint32 value);
  
  // required bytes script_bytes = 3;
  inline bool has_script_bytes() const;
  inline void clear_script_bytes();
  static const int kScriptBytesFieldNumber = 3;
  inline const ::std::string& script_bytes() const;
  inline void set_script_bytes(const ::std::string& value);
  inline void set_script_bytes(const char* value);
  inline void set_script_bytes(const void* value, size_t size);
  inline ::std::string* mutable_script_bytes();
  inline ::std::string* release_script_bytes();
  
  // optional uint32 sequence = 4;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 4;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:wallet.TransactionInput)
 private:
  inline void set_has_transaction_out_point_hash();
  inline void clear_has_transaction_out_point_hash();
  inline void set_has_transaction_out_point_index();
  inline void clear_has_transaction_out_point_index();
  inline void set_has_script_bytes();
  inline void clear_has_script_bytes();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* transaction_out_point_hash_;
  ::std::string* script_bytes_;
  ::google::protobuf::uint32 transaction_out_point_index_;
  ::google::protobuf::uint32 sequence_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static TransactionInput* default_instance_;
};
// -------------------------------------------------------------------

class TransactionOutput : public ::google::protobuf::Message {
 public:
  TransactionOutput();
  virtual ~TransactionOutput();
  
  TransactionOutput(const TransactionOutput& from);
  
  inline TransactionOutput& operator=(const TransactionOutput& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionOutput& default_instance();
  
  void Swap(TransactionOutput* other);
  
  // implements Message ----------------------------------------------
  
  TransactionOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionOutput& from);
  void MergeFrom(const TransactionOutput& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);
  
  // required bytes script_bytes = 2;
  inline bool has_script_bytes() const;
  inline void clear_script_bytes();
  static const int kScriptBytesFieldNumber = 2;
  inline const ::std::string& script_bytes() const;
  inline void set_script_bytes(const ::std::string& value);
  inline void set_script_bytes(const char* value);
  inline void set_script_bytes(const void* value, size_t size);
  inline ::std::string* mutable_script_bytes();
  inline ::std::string* release_script_bytes();
  
  // optional bytes spent_by_transaction_hash = 3;
  inline bool has_spent_by_transaction_hash() const;
  inline void clear_spent_by_transaction_hash();
  static const int kSpentByTransactionHashFieldNumber = 3;
  inline const ::std::string& spent_by_transaction_hash() const;
  inline void set_spent_by_transaction_hash(const ::std::string& value);
  inline void set_spent_by_transaction_hash(const char* value);
  inline void set_spent_by_transaction_hash(const void* value, size_t size);
  inline ::std::string* mutable_spent_by_transaction_hash();
  inline ::std::string* release_spent_by_transaction_hash();
  
  // optional int32 spent_by_transaction_index = 4;
  inline bool has_spent_by_transaction_index() const;
  inline void clear_spent_by_transaction_index();
  static const int kSpentByTransactionIndexFieldNumber = 4;
  inline ::google::protobuf::int32 spent_by_transaction_index() const;
  inline void set_spent_by_transaction_index(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:wallet.TransactionOutput)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_script_bytes();
  inline void clear_has_script_bytes();
  inline void set_has_spent_by_transaction_hash();
  inline void clear_has_spent_by_transaction_hash();
  inline void set_has_spent_by_transaction_index();
  inline void clear_has_spent_by_transaction_index();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 value_;
  ::std::string* script_bytes_;
  ::std::string* spent_by_transaction_hash_;
  ::google::protobuf::int32 spent_by_transaction_index_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static TransactionOutput* default_instance_;
};
// -------------------------------------------------------------------

class TransactionConfidence : public ::google::protobuf::Message {
 public:
  TransactionConfidence();
  virtual ~TransactionConfidence();
  
  TransactionConfidence(const TransactionConfidence& from);
  
  inline TransactionConfidence& operator=(const TransactionConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionConfidence& default_instance();
  
  void Swap(TransactionConfidence* other);
  
  // implements Message ----------------------------------------------
  
  TransactionConfidence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionConfidence& from);
  void MergeFrom(const TransactionConfidence& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TransactionConfidence_Type Type;
  static const Type UNKNOWN = TransactionConfidence_Type_UNKNOWN;
  static const Type BUILDING = TransactionConfidence_Type_BUILDING;
  static const Type PENDING = TransactionConfidence_Type_PENDING;
  static const Type NOT_IN_BEST_CHAIN = TransactionConfidence_Type_NOT_IN_BEST_CHAIN;
  static const Type DEAD = TransactionConfidence_Type_DEAD;
  static inline bool Type_IsValid(int value) {
    return TransactionConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TransactionConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    TransactionConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TransactionConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TransactionConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TransactionConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TransactionConfidence_Type_Parse(name, value);
  }
  
  typedef TransactionConfidence_Source Source;
  static const Source SOURCE_UNKNOWN = TransactionConfidence_Source_SOURCE_UNKNOWN;
  static const Source SOURCE_NETWORK = TransactionConfidence_Source_SOURCE_NETWORK;
  static const Source SOURCE_SELF = TransactionConfidence_Source_SOURCE_SELF;
  static inline bool Source_IsValid(int value) {
    return TransactionConfidence_Source_IsValid(value);
  }
  static const Source Source_MIN =
    TransactionConfidence_Source_Source_MIN;
  static const Source Source_MAX =
    TransactionConfidence_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    TransactionConfidence_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return TransactionConfidence_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return TransactionConfidence_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return TransactionConfidence_Source_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .wallet.TransactionConfidence.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::wallet::TransactionConfidence_Type type() const;
  inline void set_type(::wallet::TransactionConfidence_Type value);
  
  // optional int32 appeared_at_height = 2;
  inline bool has_appeared_at_height() const;
  inline void clear_appeared_at_height();
  static const int kAppearedAtHeightFieldNumber = 2;
  inline ::google::protobuf::int32 appeared_at_height() const;
  inline void set_appeared_at_height(::google::protobuf::int32 value);
  
  // optional bytes overriding_transaction = 3;
  inline bool has_overriding_transaction() const;
  inline void clear_overriding_transaction();
  static const int kOverridingTransactionFieldNumber = 3;
  inline const ::std::string& overriding_transaction() const;
  inline void set_overriding_transaction(const ::std::string& value);
  inline void set_overriding_transaction(const char* value);
  inline void set_overriding_transaction(const void* value, size_t size);
  inline ::std::string* mutable_overriding_transaction();
  inline ::std::string* release_overriding_transaction();
  
  // optional int32 depth = 4;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 4;
  inline ::google::protobuf::int32 depth() const;
  inline void set_depth(::google::protobuf::int32 value);
  
  // optional int64 work_done = 5;
  inline bool has_work_done() const;
  inline void clear_work_done();
  static const int kWorkDoneFieldNumber = 5;
  inline ::google::protobuf::int64 work_done() const;
  inline void set_work_done(::google::protobuf::int64 value);
  
  // repeated .wallet.PeerAddress broadcast_by = 6;
  inline int broadcast_by_size() const;
  inline void clear_broadcast_by();
  static const int kBroadcastByFieldNumber = 6;
  inline const ::wallet::PeerAddress& broadcast_by(int index) const;
  inline ::wallet::PeerAddress* mutable_broadcast_by(int index);
  inline ::wallet::PeerAddress* add_broadcast_by();
  inline const ::google::protobuf::RepeatedPtrField< ::wallet::PeerAddress >&
      broadcast_by() const;
  inline ::google::protobuf::RepeatedPtrField< ::wallet::PeerAddress >*
      mutable_broadcast_by();
  
  // optional .wallet.TransactionConfidence.Source source = 7;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 7;
  inline ::wallet::TransactionConfidence_Source source() const;
  inline void set_source(::wallet::TransactionConfidence_Source value);
  
  // @@protoc_insertion_point(class_scope:wallet.TransactionConfidence)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_appeared_at_height();
  inline void clear_has_appeared_at_height();
  inline void set_has_overriding_transaction();
  inline void clear_has_overriding_transaction();
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_work_done();
  inline void clear_has_work_done();
  inline void set_has_source();
  inline void clear_has_source();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  ::google::protobuf::int32 appeared_at_height_;
  ::std::string* overriding_transaction_;
  ::google::protobuf::int64 work_done_;
  ::google::protobuf::int32 depth_;
  int source_;
  ::google::protobuf::RepeatedPtrField< ::wallet::PeerAddress > broadcast_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static TransactionConfidence* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message {
 public:
  Transaction();
  virtual ~Transaction();
  
  Transaction(const Transaction& from);
  
  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();
  
  void Swap(Transaction* other);
  
  // implements Message ----------------------------------------------
  
  Transaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Transaction_Pool Pool;
  static const Pool UNSPENT = Transaction_Pool_UNSPENT;
  static const Pool SPENT = Transaction_Pool_SPENT;
  static const Pool INACTIVE = Transaction_Pool_INACTIVE;
  static const Pool DEAD = Transaction_Pool_DEAD;
  static const Pool PENDING = Transaction_Pool_PENDING;
  static const Pool PENDING_INACTIVE = Transaction_Pool_PENDING_INACTIVE;
  static inline bool Pool_IsValid(int value) {
    return Transaction_Pool_IsValid(value);
  }
  static const Pool Pool_MIN =
    Transaction_Pool_Pool_MIN;
  static const Pool Pool_MAX =
    Transaction_Pool_Pool_MAX;
  static const int Pool_ARRAYSIZE =
    Transaction_Pool_Pool_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Pool_descriptor() {
    return Transaction_Pool_descriptor();
  }
  static inline const ::std::string& Pool_Name(Pool value) {
    return Transaction_Pool_Name(value);
  }
  static inline bool Pool_Parse(const ::std::string& name,
      Pool* value) {
    return Transaction_Pool_Parse(name, value);
  }
  
  typedef Transaction_Purpose Purpose;
  static const Purpose UNKNOWN = Transaction_Purpose_UNKNOWN;
  static const Purpose USER_PAYMENT = Transaction_Purpose_USER_PAYMENT;
  static const Purpose KEY_ROTATION = Transaction_Purpose_KEY_ROTATION;
  static inline bool Purpose_IsValid(int value) {
    return Transaction_Purpose_IsValid(value);
  }
  static const Purpose Purpose_MIN =
    Transaction_Purpose_Purpose_MIN;
  static const Purpose Purpose_MAX =
    Transaction_Purpose_Purpose_MAX;
  static const int Purpose_ARRAYSIZE =
    Transaction_Purpose_Purpose_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Purpose_descriptor() {
    return Transaction_Purpose_descriptor();
  }
  static inline const ::std::string& Purpose_Name(Purpose value) {
    return Transaction_Purpose_Name(value);
  }
  static inline bool Purpose_Parse(const ::std::string& name,
      Purpose* value) {
    return Transaction_Purpose_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  
  // optional .wallet.Transaction.Pool pool = 3;
  inline bool has_pool() const;
  inline void clear_pool();
  static const int kPoolFieldNumber = 3;
  inline ::wallet::Transaction_Pool pool() const;
  inline void set_pool(::wallet::Transaction_Pool value);
  
  // optional uint32 lock_time = 4;
  inline bool has_lock_time() const;
  inline void clear_lock_time();
  static const int kLockTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 lock_time() const;
  inline void set_lock_time(::google::protobuf::uint32 value);
  
  // optional int64 updated_at = 5;
  inline bool has_updated_at() const;
  inline void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 5;
  inline ::google::protobuf::int64 updated_at() const;
  inline void set_updated_at(::google::protobuf::int64 value);
  
  // repeated .wallet.TransactionInput transaction_input = 6;
  inline int transaction_input_size() const;
  inline void clear_transaction_input();
  static const int kTransactionInputFieldNumber = 6;
  inline const ::wallet::TransactionInput& transaction_input(int index) const;
  inline ::wallet::TransactionInput* mutable_transaction_input(int index);
  inline ::wallet::TransactionInput* add_transaction_input();
  inline const ::google::protobuf::RepeatedPtrField< ::wallet::TransactionInput >&
      transaction_input() const;
  inline ::google::protobuf::RepeatedPtrField< ::wallet::TransactionInput >*
      mutable_transaction_input();
  
  // repeated .wallet.TransactionOutput transaction_output = 7;
  inline int transaction_output_size() const;
  inline void clear_transaction_output();
  static const int kTransactionOutputFieldNumber = 7;
  inline const ::wallet::TransactionOutput& transaction_output(int index) const;
  inline ::wallet::TransactionOutput* mutable_transaction_output(int index);
  inline ::wallet::TransactionOutput* add_transaction_output();
  inline const ::google::protobuf::RepeatedPtrField< ::wallet::TransactionOutput >&
      transaction_output() const;
  inline ::google::protobuf::RepeatedPtrField< ::wallet::TransactionOutput >*
      mutable_transaction_output();
  
  // repeated bytes block_hash = 8;
  inline int block_hash_size() const;
  inline void clear_block_hash();
  static const int kBlockHashFieldNumber = 8;
  inline const ::std::string& block_hash(int index) const;
  inline ::std::string* mutable_block_hash(int index);
  inline void set_block_hash(int index, const ::std::string& value);
  inline void set_block_hash(int index, const char* value);
  inline void set_block_hash(int index, const void* value, size_t size);
  inline ::std::string* add_block_hash();
  inline void add_block_hash(const ::std::string& value);
  inline void add_block_hash(const char* value);
  inline void add_block_hash(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& block_hash() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_block_hash();
  
  // repeated int32 block_relativity_offsets = 11;
  inline int block_relativity_offsets_size() const;
  inline void clear_block_relativity_offsets();
  static const int kBlockRelativityOffsetsFieldNumber = 11;
  inline ::google::protobuf::int32 block_relativity_offsets(int index) const;
  inline void set_block_relativity_offsets(int index, ::google::protobuf::int32 value);
  inline void add_block_relativity_offsets(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      block_relativity_offsets() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_block_relativity_offsets();
  
  // optional .wallet.TransactionConfidence confidence = 9;
  inline bool has_confidence() const;
  inline void clear_confidence();
  static const int kConfidenceFieldNumber = 9;
  inline const ::wallet::TransactionConfidence& confidence() const;
  inline ::wallet::TransactionConfidence* mutable_confidence();
  inline ::wallet::TransactionConfidence* release_confidence();
  
  // optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];
  inline bool has_purpose() const;
  inline void clear_purpose();
  static const int kPurposeFieldNumber = 10;
  inline ::wallet::Transaction_Purpose purpose() const;
  inline void set_purpose(::wallet::Transaction_Purpose value);
  
  // @@protoc_insertion_point(class_scope:wallet.Transaction)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_pool();
  inline void clear_has_pool();
  inline void set_has_lock_time();
  inline void clear_has_lock_time();
  inline void set_has_updated_at();
  inline void clear_has_updated_at();
  inline void set_has_confidence();
  inline void clear_has_confidence();
  inline void set_has_purpose();
  inline void clear_has_purpose();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* hash_;
  ::google::protobuf::int32 version_;
  int pool_;
  ::google::protobuf::int64 updated_at_;
  ::google::protobuf::RepeatedPtrField< ::wallet::TransactionInput > transaction_input_;
  ::google::protobuf::RepeatedPtrField< ::wallet::TransactionOutput > transaction_output_;
  ::google::protobuf::uint32 lock_time_;
  int purpose_;
  ::google::protobuf::RepeatedPtrField< ::std::string> block_hash_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > block_relativity_offsets_;
  ::wallet::TransactionConfidence* confidence_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class ScryptParameters : public ::google::protobuf::Message {
 public:
  ScryptParameters();
  virtual ~ScryptParameters();
  
  ScryptParameters(const ScryptParameters& from);
  
  inline ScryptParameters& operator=(const ScryptParameters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScryptParameters& default_instance();
  
  void Swap(ScryptParameters* other);
  
  // implements Message ----------------------------------------------
  
  ScryptParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScryptParameters& from);
  void MergeFrom(const ScryptParameters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes salt = 1;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 1;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const void* value, size_t size);
  inline ::std::string* mutable_salt();
  inline ::std::string* release_salt();
  
  // optional int64 n = 2 [default = 16384];
  inline bool has_n() const;
  inline void clear_n();
  static const int kNFieldNumber = 2;
  inline ::google::protobuf::int64 n() const;
  inline void set_n(::google::protobuf::int64 value);
  
  // optional int32 r = 3 [default = 8];
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline ::google::protobuf::int32 r() const;
  inline void set_r(::google::protobuf::int32 value);
  
  // optional int32 p = 4 [default = 1];
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 4;
  inline ::google::protobuf::int32 p() const;
  inline void set_p(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:wallet.ScryptParameters)
 private:
  inline void set_has_salt();
  inline void clear_has_salt();
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_p();
  inline void clear_has_p();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* salt_;
  ::google::protobuf::int64 n_;
  ::google::protobuf::int32 r_;
  ::google::protobuf::int32 p_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static ScryptParameters* default_instance_;
};
// -------------------------------------------------------------------

class Extension : public ::google::protobuf::Message {
 public:
  Extension();
  virtual ~Extension();
  
  Extension(const Extension& from);
  
  inline Extension& operator=(const Extension& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Extension& default_instance();
  
  void Swap(Extension* other);
  
  // implements Message ----------------------------------------------
  
  Extension* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Extension& from);
  void MergeFrom(const Extension& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // required bool mandatory = 3;
  inline bool has_mandatory() const;
  inline void clear_mandatory();
  static const int kMandatoryFieldNumber = 3;
  inline bool mandatory() const;
  inline void set_mandatory(bool value);
  
  // @@protoc_insertion_point(class_scope:wallet.Extension)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_mandatory();
  inline void clear_has_mandatory();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* data_;
  bool mandatory_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static Extension* default_instance_;
};
// -------------------------------------------------------------------

class Wallet : public ::google::protobuf::Message {
 public:
  Wallet();
  virtual ~Wallet();
  
  Wallet(const Wallet& from);
  
  inline Wallet& operator=(const Wallet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Wallet& default_instance();
  
  void Swap(Wallet* other);
  
  // implements Message ----------------------------------------------
  
  Wallet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Wallet& from);
  void MergeFrom(const Wallet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Wallet_EncryptionType EncryptionType;
  static const EncryptionType UNENCRYPTED = Wallet_EncryptionType_UNENCRYPTED;
  static const EncryptionType ENCRYPTED_SCRYPT_AES = Wallet_EncryptionType_ENCRYPTED_SCRYPT_AES;
  static inline bool EncryptionType_IsValid(int value) {
    return Wallet_EncryptionType_IsValid(value);
  }
  static const EncryptionType EncryptionType_MIN =
    Wallet_EncryptionType_EncryptionType_MIN;
  static const EncryptionType EncryptionType_MAX =
    Wallet_EncryptionType_EncryptionType_MAX;
  static const int EncryptionType_ARRAYSIZE =
    Wallet_EncryptionType_EncryptionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EncryptionType_descriptor() {
    return Wallet_EncryptionType_descriptor();
  }
  static inline const ::std::string& EncryptionType_Name(EncryptionType value) {
    return Wallet_EncryptionType_Name(value);
  }
  static inline bool EncryptionType_Parse(const ::std::string& name,
      EncryptionType* value) {
    return Wallet_EncryptionType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string network_identifier = 1;
  inline bool has_network_identifier() const;
  inline void clear_network_identifier();
  static const int kNetworkIdentifierFieldNumber = 1;
  inline const ::std::string& network_identifier() const;
  inline void set_network_identifier(const ::std::string& value);
  inline void set_network_identifier(const char* value);
  inline void set_network_identifier(const char* value, size_t size);
  inline ::std::string* mutable_network_identifier();
  inline ::std::string* release_network_identifier();
  
  // optional bytes last_seen_block_hash = 2;
  inline bool has_last_seen_block_hash() const;
  inline void clear_last_seen_block_hash();
  static const int kLastSeenBlockHashFieldNumber = 2;
  inline const ::std::string& last_seen_block_hash() const;
  inline void set_last_seen_block_hash(const ::std::string& value);
  inline void set_last_seen_block_hash(const char* value);
  inline void set_last_seen_block_hash(const void* value, size_t size);
  inline ::std::string* mutable_last_seen_block_hash();
  inline ::std::string* release_last_seen_block_hash();
  
  // optional uint32 last_seen_block_height = 12;
  inline bool has_last_seen_block_height() const;
  inline void clear_last_seen_block_height();
  static const int kLastSeenBlockHeightFieldNumber = 12;
  inline ::google::protobuf::uint32 last_seen_block_height() const;
  inline void set_last_seen_block_height(::google::protobuf::uint32 value);
  
  // optional int64 last_seen_block_time_secs = 14;
  inline bool has_last_seen_block_time_secs() const;
  inline void clear_last_seen_block_time_secs();
  static const int kLastSeenBlockTimeSecsFieldNumber = 14;
  inline ::google::protobuf::int64 last_seen_block_time_secs() const;
  inline void set_last_seen_block_time_secs(::google::protobuf::int64 value);
  
  // repeated .wallet.Key key = 3;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::wallet::Key& key(int index) const;
  inline ::wallet::Key* mutable_key(int index);
  inline ::wallet::Key* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::wallet::Key >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::wallet::Key >*
      mutable_key();
  
  // repeated .wallet.Transaction transaction = 4;
  inline int transaction_size() const;
  inline void clear_transaction();
  static const int kTransactionFieldNumber = 4;
  inline const ::wallet::Transaction& transaction(int index) const;
  inline ::wallet::Transaction* mutable_transaction(int index);
  inline ::wallet::Transaction* add_transaction();
  inline const ::google::protobuf::RepeatedPtrField< ::wallet::Transaction >&
      transaction() const;
  inline ::google::protobuf::RepeatedPtrField< ::wallet::Transaction >*
      mutable_transaction();
  
  // repeated .wallet.Script watched_script = 15;
  inline int watched_script_size() const;
  inline void clear_watched_script();
  static const int kWatchedScriptFieldNumber = 15;
  inline const ::wallet::Script& watched_script(int index) const;
  inline ::wallet::Script* mutable_watched_script(int index);
  inline ::wallet::Script* add_watched_script();
  inline const ::google::protobuf::RepeatedPtrField< ::wallet::Script >&
      watched_script() const;
  inline ::google::protobuf::RepeatedPtrField< ::wallet::Script >*
      mutable_watched_script();
  
  // optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];
  inline bool has_encryption_type() const;
  inline void clear_encryption_type();
  static const int kEncryptionTypeFieldNumber = 5;
  inline ::wallet::Wallet_EncryptionType encryption_type() const;
  inline void set_encryption_type(::wallet::Wallet_EncryptionType value);
  
  // optional .wallet.ScryptParameters encryption_parameters = 6;
  inline bool has_encryption_parameters() const;
  inline void clear_encryption_parameters();
  static const int kEncryptionParametersFieldNumber = 6;
  inline const ::wallet::ScryptParameters& encryption_parameters() const;
  inline ::wallet::ScryptParameters* mutable_encryption_parameters();
  inline ::wallet::ScryptParameters* release_encryption_parameters();
  
  // optional int32 version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // repeated .wallet.Extension extension = 10;
  inline int extension_size() const;
  inline void clear_extension();
  static const int kExtensionFieldNumber = 10;
  inline const ::wallet::Extension& extension(int index) const;
  inline ::wallet::Extension* mutable_extension(int index);
  inline ::wallet::Extension* add_extension();
  inline const ::google::protobuf::RepeatedPtrField< ::wallet::Extension >&
      extension() const;
  inline ::google::protobuf::RepeatedPtrField< ::wallet::Extension >*
      mutable_extension();
  
  // optional string description = 11;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 11;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional uint64 key_rotation_time = 13;
  inline bool has_key_rotation_time() const;
  inline void clear_key_rotation_time();
  static const int kKeyRotationTimeFieldNumber = 13;
  inline ::google::protobuf::uint64 key_rotation_time() const;
  inline void set_key_rotation_time(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:wallet.Wallet)
 private:
  inline void set_has_network_identifier();
  inline void clear_has_network_identifier();
  inline void set_has_last_seen_block_hash();
  inline void clear_has_last_seen_block_hash();
  inline void set_has_last_seen_block_height();
  inline void clear_has_last_seen_block_height();
  inline void set_has_last_seen_block_time_secs();
  inline void clear_has_last_seen_block_time_secs();
  inline void set_has_encryption_type();
  inline void clear_has_encryption_type();
  inline void set_has_encryption_parameters();
  inline void clear_has_encryption_parameters();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_key_rotation_time();
  inline void clear_has_key_rotation_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* network_identifier_;
  ::std::string* last_seen_block_hash_;
  ::google::protobuf::int64 last_seen_block_time_secs_;
  ::google::protobuf::RepeatedPtrField< ::wallet::Key > key_;
  ::google::protobuf::uint32 last_seen_block_height_;
  int encryption_type_;
  ::google::protobuf::RepeatedPtrField< ::wallet::Transaction > transaction_;
  ::google::protobuf::RepeatedPtrField< ::wallet::Script > watched_script_;
  ::wallet::ScryptParameters* encryption_parameters_;
  ::google::protobuf::RepeatedPtrField< ::wallet::Extension > extension_;
  ::std::string* description_;
  ::google::protobuf::uint64 key_rotation_time_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_multibit_2eproto();
  friend void protobuf_AssignDesc_multibit_2eproto();
  friend void protobuf_ShutdownFile_multibit_2eproto();
  
  void InitAsDefaultInstance();
  static Wallet* default_instance_;
};
// ===================================================================


// ===================================================================

// PeerAddress

// required bytes ip_address = 1;
inline bool PeerAddress::has_ip_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeerAddress::set_has_ip_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeerAddress::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeerAddress::clear_ip_address() {
  if (ip_address_ != &::google::protobuf::internal::kEmptyString) {
    ip_address_->clear();
  }
  clear_has_ip_address();
}
inline const ::std::string& PeerAddress::ip_address() const {
  return *ip_address_;
}
inline void PeerAddress::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void PeerAddress::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
}
inline void PeerAddress::set_ip_address(const void* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PeerAddress::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    ip_address_ = new ::std::string;
  }
  return ip_address_;
}
inline ::std::string* PeerAddress::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 port = 2;
inline bool PeerAddress::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerAddress::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerAddress::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 PeerAddress::port() const {
  return port_;
}
inline void PeerAddress::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required uint64 services = 3;
inline bool PeerAddress::has_services() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PeerAddress::set_has_services() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PeerAddress::clear_has_services() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PeerAddress::clear_services() {
  services_ = GOOGLE_ULONGLONG(0);
  clear_has_services();
}
inline ::google::protobuf::uint64 PeerAddress::services() const {
  return services_;
}
inline void PeerAddress::set_services(::google::protobuf::uint64 value) {
  set_has_services();
  services_ = value;
}

// -------------------------------------------------------------------

// EncryptedPrivateKey

// required bytes initialisation_vector = 1;
inline bool EncryptedPrivateKey::has_initialisation_vector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptedPrivateKey::set_has_initialisation_vector() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptedPrivateKey::clear_has_initialisation_vector() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptedPrivateKey::clear_initialisation_vector() {
  if (initialisation_vector_ != &::google::protobuf::internal::kEmptyString) {
    initialisation_vector_->clear();
  }
  clear_has_initialisation_vector();
}
inline const ::std::string& EncryptedPrivateKey::initialisation_vector() const {
  return *initialisation_vector_;
}
inline void EncryptedPrivateKey::set_initialisation_vector(const ::std::string& value) {
  set_has_initialisation_vector();
  if (initialisation_vector_ == &::google::protobuf::internal::kEmptyString) {
    initialisation_vector_ = new ::std::string;
  }
  initialisation_vector_->assign(value);
}
inline void EncryptedPrivateKey::set_initialisation_vector(const char* value) {
  set_has_initialisation_vector();
  if (initialisation_vector_ == &::google::protobuf::internal::kEmptyString) {
    initialisation_vector_ = new ::std::string;
  }
  initialisation_vector_->assign(value);
}
inline void EncryptedPrivateKey::set_initialisation_vector(const void* value, size_t size) {
  set_has_initialisation_vector();
  if (initialisation_vector_ == &::google::protobuf::internal::kEmptyString) {
    initialisation_vector_ = new ::std::string;
  }
  initialisation_vector_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedPrivateKey::mutable_initialisation_vector() {
  set_has_initialisation_vector();
  if (initialisation_vector_ == &::google::protobuf::internal::kEmptyString) {
    initialisation_vector_ = new ::std::string;
  }
  return initialisation_vector_;
}
inline ::std::string* EncryptedPrivateKey::release_initialisation_vector() {
  clear_has_initialisation_vector();
  if (initialisation_vector_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initialisation_vector_;
    initialisation_vector_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes encrypted_private_key = 2;
inline bool EncryptedPrivateKey::has_encrypted_private_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptedPrivateKey::set_has_encrypted_private_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptedPrivateKey::clear_has_encrypted_private_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptedPrivateKey::clear_encrypted_private_key() {
  if (encrypted_private_key_ != &::google::protobuf::internal::kEmptyString) {
    encrypted_private_key_->clear();
  }
  clear_has_encrypted_private_key();
}
inline const ::std::string& EncryptedPrivateKey::encrypted_private_key() const {
  return *encrypted_private_key_;
}
inline void EncryptedPrivateKey::set_encrypted_private_key(const ::std::string& value) {
  set_has_encrypted_private_key();
  if (encrypted_private_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_private_key_ = new ::std::string;
  }
  encrypted_private_key_->assign(value);
}
inline void EncryptedPrivateKey::set_encrypted_private_key(const char* value) {
  set_has_encrypted_private_key();
  if (encrypted_private_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_private_key_ = new ::std::string;
  }
  encrypted_private_key_->assign(value);
}
inline void EncryptedPrivateKey::set_encrypted_private_key(const void* value, size_t size) {
  set_has_encrypted_private_key();
  if (encrypted_private_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_private_key_ = new ::std::string;
  }
  encrypted_private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptedPrivateKey::mutable_encrypted_private_key() {
  set_has_encrypted_private_key();
  if (encrypted_private_key_ == &::google::protobuf::internal::kEmptyString) {
    encrypted_private_key_ = new ::std::string;
  }
  return encrypted_private_key_;
}
inline ::std::string* EncryptedPrivateKey::release_encrypted_private_key() {
  clear_has_encrypted_private_key();
  if (encrypted_private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_private_key_;
    encrypted_private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Key

// required .wallet.Key.Type type = 1;
inline bool Key::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Key::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Key::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Key::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::wallet::Key_Type Key::type() const {
  return static_cast< ::wallet::Key_Type >(type_);
}
inline void Key::set_type(::wallet::Key_Type value) {
  GOOGLE_DCHECK(::wallet::Key_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes private_key = 2;
inline bool Key::has_private_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Key::set_has_private_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Key::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Key::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& Key::private_key() const {
  return *private_key_;
}
inline void Key::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Key::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Key::set_private_key(const void* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}
inline ::std::string* Key::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .wallet.EncryptedPrivateKey encrypted_private_key = 6;
inline bool Key::has_encrypted_private_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Key::set_has_encrypted_private_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Key::clear_has_encrypted_private_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Key::clear_encrypted_private_key() {
  if (encrypted_private_key_ != NULL) encrypted_private_key_->::wallet::EncryptedPrivateKey::Clear();
  clear_has_encrypted_private_key();
}
inline const ::wallet::EncryptedPrivateKey& Key::encrypted_private_key() const {
  return encrypted_private_key_ != NULL ? *encrypted_private_key_ : *default_instance_->encrypted_private_key_;
}
inline ::wallet::EncryptedPrivateKey* Key::mutable_encrypted_private_key() {
  set_has_encrypted_private_key();
  if (encrypted_private_key_ == NULL) encrypted_private_key_ = new ::wallet::EncryptedPrivateKey;
  return encrypted_private_key_;
}
inline ::wallet::EncryptedPrivateKey* Key::release_encrypted_private_key() {
  clear_has_encrypted_private_key();
  ::wallet::EncryptedPrivateKey* temp = encrypted_private_key_;
  encrypted_private_key_ = NULL;
  return temp;
}

// optional bytes public_key = 3;
inline bool Key::has_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Key::set_has_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Key::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Key::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& Key::public_key() const {
  return *public_key_;
}
inline void Key::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Key::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Key::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* Key::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string label = 4;
inline bool Key::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Key::set_has_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Key::clear_has_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Key::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Key::label() const {
  return *label_;
}
inline void Key::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Key::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Key::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* Key::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 creation_timestamp = 5;
inline bool Key::has_creation_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Key::set_has_creation_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Key::clear_has_creation_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Key::clear_creation_timestamp() {
  creation_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_creation_timestamp();
}
inline ::google::protobuf::int64 Key::creation_timestamp() const {
  return creation_timestamp_;
}
inline void Key::set_creation_timestamp(::google::protobuf::int64 value) {
  set_has_creation_timestamp();
  creation_timestamp_ = value;
}

// -------------------------------------------------------------------

// Script

// required bytes program = 1;
inline bool Script::has_program() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Script::set_has_program() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Script::clear_has_program() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Script::clear_program() {
  if (program_ != &::google::protobuf::internal::kEmptyString) {
    program_->clear();
  }
  clear_has_program();
}
inline const ::std::string& Script::program() const {
  return *program_;
}
inline void Script::set_program(const ::std::string& value) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void Script::set_program(const char* value) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void Script::set_program(const void* value, size_t size) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    program_ = new ::std::string;
  }
  program_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Script::mutable_program() {
  set_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    program_ = new ::std::string;
  }
  return program_;
}
inline ::std::string* Script::release_program() {
  clear_has_program();
  if (program_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = program_;
    program_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 creation_timestamp = 2;
inline bool Script::has_creation_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Script::set_has_creation_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Script::clear_has_creation_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Script::clear_creation_timestamp() {
  creation_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_creation_timestamp();
}
inline ::google::protobuf::int64 Script::creation_timestamp() const {
  return creation_timestamp_;
}
inline void Script::set_creation_timestamp(::google::protobuf::int64 value) {
  set_has_creation_timestamp();
  creation_timestamp_ = value;
}

// -------------------------------------------------------------------

// TransactionInput

// required bytes transaction_out_point_hash = 1;
inline bool TransactionInput::has_transaction_out_point_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionInput::set_has_transaction_out_point_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionInput::clear_has_transaction_out_point_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionInput::clear_transaction_out_point_hash() {
  if (transaction_out_point_hash_ != &::google::protobuf::internal::kEmptyString) {
    transaction_out_point_hash_->clear();
  }
  clear_has_transaction_out_point_hash();
}
inline const ::std::string& TransactionInput::transaction_out_point_hash() const {
  return *transaction_out_point_hash_;
}
inline void TransactionInput::set_transaction_out_point_hash(const ::std::string& value) {
  set_has_transaction_out_point_hash();
  if (transaction_out_point_hash_ == &::google::protobuf::internal::kEmptyString) {
    transaction_out_point_hash_ = new ::std::string;
  }
  transaction_out_point_hash_->assign(value);
}
inline void TransactionInput::set_transaction_out_point_hash(const char* value) {
  set_has_transaction_out_point_hash();
  if (transaction_out_point_hash_ == &::google::protobuf::internal::kEmptyString) {
    transaction_out_point_hash_ = new ::std::string;
  }
  transaction_out_point_hash_->assign(value);
}
inline void TransactionInput::set_transaction_out_point_hash(const void* value, size_t size) {
  set_has_transaction_out_point_hash();
  if (transaction_out_point_hash_ == &::google::protobuf::internal::kEmptyString) {
    transaction_out_point_hash_ = new ::std::string;
  }
  transaction_out_point_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionInput::mutable_transaction_out_point_hash() {
  set_has_transaction_out_point_hash();
  if (transaction_out_point_hash_ == &::google::protobuf::internal::kEmptyString) {
    transaction_out_point_hash_ = new ::std::string;
  }
  return transaction_out_point_hash_;
}
inline ::std::string* TransactionInput::release_transaction_out_point_hash() {
  clear_has_transaction_out_point_hash();
  if (transaction_out_point_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transaction_out_point_hash_;
    transaction_out_point_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 transaction_out_point_index = 2;
inline bool TransactionInput::has_transaction_out_point_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionInput::set_has_transaction_out_point_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionInput::clear_has_transaction_out_point_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionInput::clear_transaction_out_point_index() {
  transaction_out_point_index_ = 0u;
  clear_has_transaction_out_point_index();
}
inline ::google::protobuf::uint32 TransactionInput::transaction_out_point_index() const {
  return transaction_out_point_index_;
}
inline void TransactionInput::set_transaction_out_point_index(::google::protobuf::uint32 value) {
  set_has_transaction_out_point_index();
  transaction_out_point_index_ = value;
}

// required bytes script_bytes = 3;
inline bool TransactionInput::has_script_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionInput::set_has_script_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionInput::clear_has_script_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionInput::clear_script_bytes() {
  if (script_bytes_ != &::google::protobuf::internal::kEmptyString) {
    script_bytes_->clear();
  }
  clear_has_script_bytes();
}
inline const ::std::string& TransactionInput::script_bytes() const {
  return *script_bytes_;
}
inline void TransactionInput::set_script_bytes(const ::std::string& value) {
  set_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    script_bytes_ = new ::std::string;
  }
  script_bytes_->assign(value);
}
inline void TransactionInput::set_script_bytes(const char* value) {
  set_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    script_bytes_ = new ::std::string;
  }
  script_bytes_->assign(value);
}
inline void TransactionInput::set_script_bytes(const void* value, size_t size) {
  set_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    script_bytes_ = new ::std::string;
  }
  script_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionInput::mutable_script_bytes() {
  set_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    script_bytes_ = new ::std::string;
  }
  return script_bytes_;
}
inline ::std::string* TransactionInput::release_script_bytes() {
  clear_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_bytes_;
    script_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 sequence = 4;
inline bool TransactionInput::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionInput::set_has_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionInput::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionInput::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 TransactionInput::sequence() const {
  return sequence_;
}
inline void TransactionInput::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// -------------------------------------------------------------------

// TransactionOutput

// required int64 value = 1;
inline bool TransactionOutput::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionOutput::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionOutput::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionOutput::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 TransactionOutput::value() const {
  return value_;
}
inline void TransactionOutput::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
}

// required bytes script_bytes = 2;
inline bool TransactionOutput::has_script_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionOutput::set_has_script_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionOutput::clear_has_script_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionOutput::clear_script_bytes() {
  if (script_bytes_ != &::google::protobuf::internal::kEmptyString) {
    script_bytes_->clear();
  }
  clear_has_script_bytes();
}
inline const ::std::string& TransactionOutput::script_bytes() const {
  return *script_bytes_;
}
inline void TransactionOutput::set_script_bytes(const ::std::string& value) {
  set_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    script_bytes_ = new ::std::string;
  }
  script_bytes_->assign(value);
}
inline void TransactionOutput::set_script_bytes(const char* value) {
  set_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    script_bytes_ = new ::std::string;
  }
  script_bytes_->assign(value);
}
inline void TransactionOutput::set_script_bytes(const void* value, size_t size) {
  set_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    script_bytes_ = new ::std::string;
  }
  script_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionOutput::mutable_script_bytes() {
  set_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    script_bytes_ = new ::std::string;
  }
  return script_bytes_;
}
inline ::std::string* TransactionOutput::release_script_bytes() {
  clear_has_script_bytes();
  if (script_bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_bytes_;
    script_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes spent_by_transaction_hash = 3;
inline bool TransactionOutput::has_spent_by_transaction_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionOutput::set_has_spent_by_transaction_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionOutput::clear_has_spent_by_transaction_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionOutput::clear_spent_by_transaction_hash() {
  if (spent_by_transaction_hash_ != &::google::protobuf::internal::kEmptyString) {
    spent_by_transaction_hash_->clear();
  }
  clear_has_spent_by_transaction_hash();
}
inline const ::std::string& TransactionOutput::spent_by_transaction_hash() const {
  return *spent_by_transaction_hash_;
}
inline void TransactionOutput::set_spent_by_transaction_hash(const ::std::string& value) {
  set_has_spent_by_transaction_hash();
  if (spent_by_transaction_hash_ == &::google::protobuf::internal::kEmptyString) {
    spent_by_transaction_hash_ = new ::std::string;
  }
  spent_by_transaction_hash_->assign(value);
}
inline void TransactionOutput::set_spent_by_transaction_hash(const char* value) {
  set_has_spent_by_transaction_hash();
  if (spent_by_transaction_hash_ == &::google::protobuf::internal::kEmptyString) {
    spent_by_transaction_hash_ = new ::std::string;
  }
  spent_by_transaction_hash_->assign(value);
}
inline void TransactionOutput::set_spent_by_transaction_hash(const void* value, size_t size) {
  set_has_spent_by_transaction_hash();
  if (spent_by_transaction_hash_ == &::google::protobuf::internal::kEmptyString) {
    spent_by_transaction_hash_ = new ::std::string;
  }
  spent_by_transaction_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionOutput::mutable_spent_by_transaction_hash() {
  set_has_spent_by_transaction_hash();
  if (spent_by_transaction_hash_ == &::google::protobuf::internal::kEmptyString) {
    spent_by_transaction_hash_ = new ::std::string;
  }
  return spent_by_transaction_hash_;
}
inline ::std::string* TransactionOutput::release_spent_by_transaction_hash() {
  clear_has_spent_by_transaction_hash();
  if (spent_by_transaction_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spent_by_transaction_hash_;
    spent_by_transaction_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 spent_by_transaction_index = 4;
inline bool TransactionOutput::has_spent_by_transaction_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionOutput::set_has_spent_by_transaction_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionOutput::clear_has_spent_by_transaction_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionOutput::clear_spent_by_transaction_index() {
  spent_by_transaction_index_ = 0;
  clear_has_spent_by_transaction_index();
}
inline ::google::protobuf::int32 TransactionOutput::spent_by_transaction_index() const {
  return spent_by_transaction_index_;
}
inline void TransactionOutput::set_spent_by_transaction_index(::google::protobuf::int32 value) {
  set_has_spent_by_transaction_index();
  spent_by_transaction_index_ = value;
}

// -------------------------------------------------------------------

// TransactionConfidence

// optional .wallet.TransactionConfidence.Type type = 1;
inline bool TransactionConfidence::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionConfidence::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionConfidence::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionConfidence::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::wallet::TransactionConfidence_Type TransactionConfidence::type() const {
  return static_cast< ::wallet::TransactionConfidence_Type >(type_);
}
inline void TransactionConfidence::set_type(::wallet::TransactionConfidence_Type value) {
  GOOGLE_DCHECK(::wallet::TransactionConfidence_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 appeared_at_height = 2;
inline bool TransactionConfidence::has_appeared_at_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionConfidence::set_has_appeared_at_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionConfidence::clear_has_appeared_at_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionConfidence::clear_appeared_at_height() {
  appeared_at_height_ = 0;
  clear_has_appeared_at_height();
}
inline ::google::protobuf::int32 TransactionConfidence::appeared_at_height() const {
  return appeared_at_height_;
}
inline void TransactionConfidence::set_appeared_at_height(::google::protobuf::int32 value) {
  set_has_appeared_at_height();
  appeared_at_height_ = value;
}

// optional bytes overriding_transaction = 3;
inline bool TransactionConfidence::has_overriding_transaction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionConfidence::set_has_overriding_transaction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionConfidence::clear_has_overriding_transaction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionConfidence::clear_overriding_transaction() {
  if (overriding_transaction_ != &::google::protobuf::internal::kEmptyString) {
    overriding_transaction_->clear();
  }
  clear_has_overriding_transaction();
}
inline const ::std::string& TransactionConfidence::overriding_transaction() const {
  return *overriding_transaction_;
}
inline void TransactionConfidence::set_overriding_transaction(const ::std::string& value) {
  set_has_overriding_transaction();
  if (overriding_transaction_ == &::google::protobuf::internal::kEmptyString) {
    overriding_transaction_ = new ::std::string;
  }
  overriding_transaction_->assign(value);
}
inline void TransactionConfidence::set_overriding_transaction(const char* value) {
  set_has_overriding_transaction();
  if (overriding_transaction_ == &::google::protobuf::internal::kEmptyString) {
    overriding_transaction_ = new ::std::string;
  }
  overriding_transaction_->assign(value);
}
inline void TransactionConfidence::set_overriding_transaction(const void* value, size_t size) {
  set_has_overriding_transaction();
  if (overriding_transaction_ == &::google::protobuf::internal::kEmptyString) {
    overriding_transaction_ = new ::std::string;
  }
  overriding_transaction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionConfidence::mutable_overriding_transaction() {
  set_has_overriding_transaction();
  if (overriding_transaction_ == &::google::protobuf::internal::kEmptyString) {
    overriding_transaction_ = new ::std::string;
  }
  return overriding_transaction_;
}
inline ::std::string* TransactionConfidence::release_overriding_transaction() {
  clear_has_overriding_transaction();
  if (overriding_transaction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = overriding_transaction_;
    overriding_transaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 depth = 4;
inline bool TransactionConfidence::has_depth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionConfidence::set_has_depth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionConfidence::clear_has_depth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionConfidence::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline ::google::protobuf::int32 TransactionConfidence::depth() const {
  return depth_;
}
inline void TransactionConfidence::set_depth(::google::protobuf::int32 value) {
  set_has_depth();
  depth_ = value;
}

// optional int64 work_done = 5;
inline bool TransactionConfidence::has_work_done() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransactionConfidence::set_has_work_done() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransactionConfidence::clear_has_work_done() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransactionConfidence::clear_work_done() {
  work_done_ = GOOGLE_LONGLONG(0);
  clear_has_work_done();
}
inline ::google::protobuf::int64 TransactionConfidence::work_done() const {
  return work_done_;
}
inline void TransactionConfidence::set_work_done(::google::protobuf::int64 value) {
  set_has_work_done();
  work_done_ = value;
}

// repeated .wallet.PeerAddress broadcast_by = 6;
inline int TransactionConfidence::broadcast_by_size() const {
  return broadcast_by_.size();
}
inline void TransactionConfidence::clear_broadcast_by() {
  broadcast_by_.Clear();
}
inline const ::wallet::PeerAddress& TransactionConfidence::broadcast_by(int index) const {
  return broadcast_by_.Get(index);
}
inline ::wallet::PeerAddress* TransactionConfidence::mutable_broadcast_by(int index) {
  return broadcast_by_.Mutable(index);
}
inline ::wallet::PeerAddress* TransactionConfidence::add_broadcast_by() {
  return broadcast_by_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wallet::PeerAddress >&
TransactionConfidence::broadcast_by() const {
  return broadcast_by_;
}
inline ::google::protobuf::RepeatedPtrField< ::wallet::PeerAddress >*
TransactionConfidence::mutable_broadcast_by() {
  return &broadcast_by_;
}

// optional .wallet.TransactionConfidence.Source source = 7;
inline bool TransactionConfidence::has_source() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransactionConfidence::set_has_source() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransactionConfidence::clear_has_source() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransactionConfidence::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::wallet::TransactionConfidence_Source TransactionConfidence::source() const {
  return static_cast< ::wallet::TransactionConfidence_Source >(source_);
}
inline void TransactionConfidence::set_source(::wallet::TransactionConfidence_Source value) {
  GOOGLE_DCHECK(::wallet::TransactionConfidence_Source_IsValid(value));
  set_has_source();
  source_ = value;
}

// -------------------------------------------------------------------

// Transaction

// required int32 version = 1;
inline bool Transaction::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transaction::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transaction::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transaction::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Transaction::version() const {
  return version_;
}
inline void Transaction::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required bytes hash = 2;
inline bool Transaction::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transaction::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transaction::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transaction::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& Transaction::hash() const {
  return *hash_;
}
inline void Transaction::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Transaction::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void Transaction::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* Transaction::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .wallet.Transaction.Pool pool = 3;
inline bool Transaction::has_pool() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transaction::set_has_pool() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transaction::clear_has_pool() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transaction::clear_pool() {
  pool_ = 4;
  clear_has_pool();
}
inline ::wallet::Transaction_Pool Transaction::pool() const {
  return static_cast< ::wallet::Transaction_Pool >(pool_);
}
inline void Transaction::set_pool(::wallet::Transaction_Pool value) {
  GOOGLE_DCHECK(::wallet::Transaction_Pool_IsValid(value));
  set_has_pool();
  pool_ = value;
}

// optional uint32 lock_time = 4;
inline bool Transaction::has_lock_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transaction::set_has_lock_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transaction::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transaction::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
inline ::google::protobuf::uint32 Transaction::lock_time() const {
  return lock_time_;
}
inline void Transaction::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
}

// optional int64 updated_at = 5;
inline bool Transaction::has_updated_at() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transaction::set_has_updated_at() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transaction::clear_has_updated_at() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transaction::clear_updated_at() {
  updated_at_ = GOOGLE_LONGLONG(0);
  clear_has_updated_at();
}
inline ::google::protobuf::int64 Transaction::updated_at() const {
  return updated_at_;
}
inline void Transaction::set_updated_at(::google::protobuf::int64 value) {
  set_has_updated_at();
  updated_at_ = value;
}

// repeated .wallet.TransactionInput transaction_input = 6;
inline int Transaction::transaction_input_size() const {
  return transaction_input_.size();
}
inline void Transaction::clear_transaction_input() {
  transaction_input_.Clear();
}
inline const ::wallet::TransactionInput& Transaction::transaction_input(int index) const {
  return transaction_input_.Get(index);
}
inline ::wallet::TransactionInput* Transaction::mutable_transaction_input(int index) {
  return transaction_input_.Mutable(index);
}
inline ::wallet::TransactionInput* Transaction::add_transaction_input() {
  return transaction_input_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wallet::TransactionInput >&
Transaction::transaction_input() const {
  return transaction_input_;
}
inline ::google::protobuf::RepeatedPtrField< ::wallet::TransactionInput >*
Transaction::mutable_transaction_input() {
  return &transaction_input_;
}

// repeated .wallet.TransactionOutput transaction_output = 7;
inline int Transaction::transaction_output_size() const {
  return transaction_output_.size();
}
inline void Transaction::clear_transaction_output() {
  transaction_output_.Clear();
}
inline const ::wallet::TransactionOutput& Transaction::transaction_output(int index) const {
  return transaction_output_.Get(index);
}
inline ::wallet::TransactionOutput* Transaction::mutable_transaction_output(int index) {
  return transaction_output_.Mutable(index);
}
inline ::wallet::TransactionOutput* Transaction::add_transaction_output() {
  return transaction_output_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wallet::TransactionOutput >&
Transaction::transaction_output() const {
  return transaction_output_;
}
inline ::google::protobuf::RepeatedPtrField< ::wallet::TransactionOutput >*
Transaction::mutable_transaction_output() {
  return &transaction_output_;
}

// repeated bytes block_hash = 8;
inline int Transaction::block_hash_size() const {
  return block_hash_.size();
}
inline void Transaction::clear_block_hash() {
  block_hash_.Clear();
}
inline const ::std::string& Transaction::block_hash(int index) const {
  return block_hash_.Get(index);
}
inline ::std::string* Transaction::mutable_block_hash(int index) {
  return block_hash_.Mutable(index);
}
inline void Transaction::set_block_hash(int index, const ::std::string& value) {
  block_hash_.Mutable(index)->assign(value);
}
inline void Transaction::set_block_hash(int index, const char* value) {
  block_hash_.Mutable(index)->assign(value);
}
inline void Transaction::set_block_hash(int index, const void* value, size_t size) {
  block_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::add_block_hash() {
  return block_hash_.Add();
}
inline void Transaction::add_block_hash(const ::std::string& value) {
  block_hash_.Add()->assign(value);
}
inline void Transaction::add_block_hash(const char* value) {
  block_hash_.Add()->assign(value);
}
inline void Transaction::add_block_hash(const void* value, size_t size) {
  block_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Transaction::block_hash() const {
  return block_hash_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Transaction::mutable_block_hash() {
  return &block_hash_;
}

// repeated int32 block_relativity_offsets = 11;
inline int Transaction::block_relativity_offsets_size() const {
  return block_relativity_offsets_.size();
}
inline void Transaction::clear_block_relativity_offsets() {
  block_relativity_offsets_.Clear();
}
inline ::google::protobuf::int32 Transaction::block_relativity_offsets(int index) const {
  return block_relativity_offsets_.Get(index);
}
inline void Transaction::set_block_relativity_offsets(int index, ::google::protobuf::int32 value) {
  block_relativity_offsets_.Set(index, value);
}
inline void Transaction::add_block_relativity_offsets(::google::protobuf::int32 value) {
  block_relativity_offsets_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Transaction::block_relativity_offsets() const {
  return block_relativity_offsets_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Transaction::mutable_block_relativity_offsets() {
  return &block_relativity_offsets_;
}

// optional .wallet.TransactionConfidence confidence = 9;
inline bool Transaction::has_confidence() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Transaction::set_has_confidence() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Transaction::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Transaction::clear_confidence() {
  if (confidence_ != NULL) confidence_->::wallet::TransactionConfidence::Clear();
  clear_has_confidence();
}
inline const ::wallet::TransactionConfidence& Transaction::confidence() const {
  return confidence_ != NULL ? *confidence_ : *default_instance_->confidence_;
}
inline ::wallet::TransactionConfidence* Transaction::mutable_confidence() {
  set_has_confidence();
  if (confidence_ == NULL) confidence_ = new ::wallet::TransactionConfidence;
  return confidence_;
}
inline ::wallet::TransactionConfidence* Transaction::release_confidence() {
  clear_has_confidence();
  ::wallet::TransactionConfidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}

// optional .wallet.Transaction.Purpose purpose = 10 [default = UNKNOWN];
inline bool Transaction::has_purpose() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Transaction::set_has_purpose() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Transaction::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Transaction::clear_purpose() {
  purpose_ = 0;
  clear_has_purpose();
}
inline ::wallet::Transaction_Purpose Transaction::purpose() const {
  return static_cast< ::wallet::Transaction_Purpose >(purpose_);
}
inline void Transaction::set_purpose(::wallet::Transaction_Purpose value) {
  GOOGLE_DCHECK(::wallet::Transaction_Purpose_IsValid(value));
  set_has_purpose();
  purpose_ = value;
}

// -------------------------------------------------------------------

// ScryptParameters

// required bytes salt = 1;
inline bool ScryptParameters::has_salt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScryptParameters::set_has_salt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScryptParameters::clear_has_salt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScryptParameters::clear_salt() {
  if (salt_ != &::google::protobuf::internal::kEmptyString) {
    salt_->clear();
  }
  clear_has_salt();
}
inline const ::std::string& ScryptParameters::salt() const {
  return *salt_;
}
inline void ScryptParameters::set_salt(const ::std::string& value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void ScryptParameters::set_salt(const char* value) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void ScryptParameters::set_salt(const void* value, size_t size) {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScryptParameters::mutable_salt() {
  set_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    salt_ = new ::std::string;
  }
  return salt_;
}
inline ::std::string* ScryptParameters::release_salt() {
  clear_has_salt();
  if (salt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = salt_;
    salt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 n = 2 [default = 16384];
inline bool ScryptParameters::has_n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScryptParameters::set_has_n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScryptParameters::clear_has_n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScryptParameters::clear_n() {
  n_ = GOOGLE_LONGLONG(16384);
  clear_has_n();
}
inline ::google::protobuf::int64 ScryptParameters::n() const {
  return n_;
}
inline void ScryptParameters::set_n(::google::protobuf::int64 value) {
  set_has_n();
  n_ = value;
}

// optional int32 r = 3 [default = 8];
inline bool ScryptParameters::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScryptParameters::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScryptParameters::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScryptParameters::clear_r() {
  r_ = 8;
  clear_has_r();
}
inline ::google::protobuf::int32 ScryptParameters::r() const {
  return r_;
}
inline void ScryptParameters::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
}

// optional int32 p = 4 [default = 1];
inline bool ScryptParameters::has_p() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScryptParameters::set_has_p() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScryptParameters::clear_has_p() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScryptParameters::clear_p() {
  p_ = 1;
  clear_has_p();
}
inline ::google::protobuf::int32 ScryptParameters::p() const {
  return p_;
}
inline void ScryptParameters::set_p(::google::protobuf::int32 value) {
  set_has_p();
  p_ = value;
}

// -------------------------------------------------------------------

// Extension

// required string id = 1;
inline bool Extension::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extension::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Extension::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Extension::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Extension::id() const {
  return *id_;
}
inline void Extension::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Extension::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Extension::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extension::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Extension::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bytes data = 2;
inline bool Extension::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Extension::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Extension::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Extension::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Extension::data() const {
  return *data_;
}
inline void Extension::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Extension::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Extension::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extension::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Extension::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool mandatory = 3;
inline bool Extension::has_mandatory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Extension::set_has_mandatory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Extension::clear_has_mandatory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Extension::clear_mandatory() {
  mandatory_ = false;
  clear_has_mandatory();
}
inline bool Extension::mandatory() const {
  return mandatory_;
}
inline void Extension::set_mandatory(bool value) {
  set_has_mandatory();
  mandatory_ = value;
}

// -------------------------------------------------------------------

// Wallet

// required string network_identifier = 1;
inline bool Wallet::has_network_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Wallet::set_has_network_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Wallet::clear_has_network_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Wallet::clear_network_identifier() {
  if (network_identifier_ != &::google::protobuf::internal::kEmptyString) {
    network_identifier_->clear();
  }
  clear_has_network_identifier();
}
inline const ::std::string& Wallet::network_identifier() const {
  return *network_identifier_;
}
inline void Wallet::set_network_identifier(const ::std::string& value) {
  set_has_network_identifier();
  if (network_identifier_ == &::google::protobuf::internal::kEmptyString) {
    network_identifier_ = new ::std::string;
  }
  network_identifier_->assign(value);
}
inline void Wallet::set_network_identifier(const char* value) {
  set_has_network_identifier();
  if (network_identifier_ == &::google::protobuf::internal::kEmptyString) {
    network_identifier_ = new ::std::string;
  }
  network_identifier_->assign(value);
}
inline void Wallet::set_network_identifier(const char* value, size_t size) {
  set_has_network_identifier();
  if (network_identifier_ == &::google::protobuf::internal::kEmptyString) {
    network_identifier_ = new ::std::string;
  }
  network_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Wallet::mutable_network_identifier() {
  set_has_network_identifier();
  if (network_identifier_ == &::google::protobuf::internal::kEmptyString) {
    network_identifier_ = new ::std::string;
  }
  return network_identifier_;
}
inline ::std::string* Wallet::release_network_identifier() {
  clear_has_network_identifier();
  if (network_identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = network_identifier_;
    network_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes last_seen_block_hash = 2;
inline bool Wallet::has_last_seen_block_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Wallet::set_has_last_seen_block_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Wallet::clear_has_last_seen_block_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Wallet::clear_last_seen_block_hash() {
  if (last_seen_block_hash_ != &::google::protobuf::internal::kEmptyString) {
    last_seen_block_hash_->clear();
  }
  clear_has_last_seen_block_hash();
}
inline const ::std::string& Wallet::last_seen_block_hash() const {
  return *last_seen_block_hash_;
}
inline void Wallet::set_last_seen_block_hash(const ::std::string& value) {
  set_has_last_seen_block_hash();
  if (last_seen_block_hash_ == &::google::protobuf::internal::kEmptyString) {
    last_seen_block_hash_ = new ::std::string;
  }
  last_seen_block_hash_->assign(value);
}
inline void Wallet::set_last_seen_block_hash(const char* value) {
  set_has_last_seen_block_hash();
  if (last_seen_block_hash_ == &::google::protobuf::internal::kEmptyString) {
    last_seen_block_hash_ = new ::std::string;
  }
  last_seen_block_hash_->assign(value);
}
inline void Wallet::set_last_seen_block_hash(const void* value, size_t size) {
  set_has_last_seen_block_hash();
  if (last_seen_block_hash_ == &::google::protobuf::internal::kEmptyString) {
    last_seen_block_hash_ = new ::std::string;
  }
  last_seen_block_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Wallet::mutable_last_seen_block_hash() {
  set_has_last_seen_block_hash();
  if (last_seen_block_hash_ == &::google::protobuf::internal::kEmptyString) {
    last_seen_block_hash_ = new ::std::string;
  }
  return last_seen_block_hash_;
}
inline ::std::string* Wallet::release_last_seen_block_hash() {
  clear_has_last_seen_block_hash();
  if (last_seen_block_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_seen_block_hash_;
    last_seen_block_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 last_seen_block_height = 12;
inline bool Wallet::has_last_seen_block_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Wallet::set_has_last_seen_block_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Wallet::clear_has_last_seen_block_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Wallet::clear_last_seen_block_height() {
  last_seen_block_height_ = 0u;
  clear_has_last_seen_block_height();
}
inline ::google::protobuf::uint32 Wallet::last_seen_block_height() const {
  return last_seen_block_height_;
}
inline void Wallet::set_last_seen_block_height(::google::protobuf::uint32 value) {
  set_has_last_seen_block_height();
  last_seen_block_height_ = value;
}

// optional int64 last_seen_block_time_secs = 14;
inline bool Wallet::has_last_seen_block_time_secs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Wallet::set_has_last_seen_block_time_secs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Wallet::clear_has_last_seen_block_time_secs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Wallet::clear_last_seen_block_time_secs() {
  last_seen_block_time_secs_ = GOOGLE_LONGLONG(0);
  clear_has_last_seen_block_time_secs();
}
inline ::google::protobuf::int64 Wallet::last_seen_block_time_secs() const {
  return last_seen_block_time_secs_;
}
inline void Wallet::set_last_seen_block_time_secs(::google::protobuf::int64 value) {
  set_has_last_seen_block_time_secs();
  last_seen_block_time_secs_ = value;
}

// repeated .wallet.Key key = 3;
inline int Wallet::key_size() const {
  return key_.size();
}
inline void Wallet::clear_key() {
  key_.Clear();
}
inline const ::wallet::Key& Wallet::key(int index) const {
  return key_.Get(index);
}
inline ::wallet::Key* Wallet::mutable_key(int index) {
  return key_.Mutable(index);
}
inline ::wallet::Key* Wallet::add_key() {
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wallet::Key >&
Wallet::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::wallet::Key >*
Wallet::mutable_key() {
  return &key_;
}

// repeated .wallet.Transaction transaction = 4;
inline int Wallet::transaction_size() const {
  return transaction_.size();
}
inline void Wallet::clear_transaction() {
  transaction_.Clear();
}
inline const ::wallet::Transaction& Wallet::transaction(int index) const {
  return transaction_.Get(index);
}
inline ::wallet::Transaction* Wallet::mutable_transaction(int index) {
  return transaction_.Mutable(index);
}
inline ::wallet::Transaction* Wallet::add_transaction() {
  return transaction_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wallet::Transaction >&
Wallet::transaction() const {
  return transaction_;
}
inline ::google::protobuf::RepeatedPtrField< ::wallet::Transaction >*
Wallet::mutable_transaction() {
  return &transaction_;
}

// repeated .wallet.Script watched_script = 15;
inline int Wallet::watched_script_size() const {
  return watched_script_.size();
}
inline void Wallet::clear_watched_script() {
  watched_script_.Clear();
}
inline const ::wallet::Script& Wallet::watched_script(int index) const {
  return watched_script_.Get(index);
}
inline ::wallet::Script* Wallet::mutable_watched_script(int index) {
  return watched_script_.Mutable(index);
}
inline ::wallet::Script* Wallet::add_watched_script() {
  return watched_script_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wallet::Script >&
Wallet::watched_script() const {
  return watched_script_;
}
inline ::google::protobuf::RepeatedPtrField< ::wallet::Script >*
Wallet::mutable_watched_script() {
  return &watched_script_;
}

// optional .wallet.Wallet.EncryptionType encryption_type = 5 [default = UNENCRYPTED];
inline bool Wallet::has_encryption_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Wallet::set_has_encryption_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Wallet::clear_has_encryption_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Wallet::clear_encryption_type() {
  encryption_type_ = 1;
  clear_has_encryption_type();
}
inline ::wallet::Wallet_EncryptionType Wallet::encryption_type() const {
  return static_cast< ::wallet::Wallet_EncryptionType >(encryption_type_);
}
inline void Wallet::set_encryption_type(::wallet::Wallet_EncryptionType value) {
  GOOGLE_DCHECK(::wallet::Wallet_EncryptionType_IsValid(value));
  set_has_encryption_type();
  encryption_type_ = value;
}

// optional .wallet.ScryptParameters encryption_parameters = 6;
inline bool Wallet::has_encryption_parameters() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Wallet::set_has_encryption_parameters() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Wallet::clear_has_encryption_parameters() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Wallet::clear_encryption_parameters() {
  if (encryption_parameters_ != NULL) encryption_parameters_->::wallet::ScryptParameters::Clear();
  clear_has_encryption_parameters();
}
inline const ::wallet::ScryptParameters& Wallet::encryption_parameters() const {
  return encryption_parameters_ != NULL ? *encryption_parameters_ : *default_instance_->encryption_parameters_;
}
inline ::wallet::ScryptParameters* Wallet::mutable_encryption_parameters() {
  set_has_encryption_parameters();
  if (encryption_parameters_ == NULL) encryption_parameters_ = new ::wallet::ScryptParameters;
  return encryption_parameters_;
}
inline ::wallet::ScryptParameters* Wallet::release_encryption_parameters() {
  clear_has_encryption_parameters();
  ::wallet::ScryptParameters* temp = encryption_parameters_;
  encryption_parameters_ = NULL;
  return temp;
}

// optional int32 version = 7;
inline bool Wallet::has_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Wallet::set_has_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Wallet::clear_has_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Wallet::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Wallet::version() const {
  return version_;
}
inline void Wallet::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// repeated .wallet.Extension extension = 10;
inline int Wallet::extension_size() const {
  return extension_.size();
}
inline void Wallet::clear_extension() {
  extension_.Clear();
}
inline const ::wallet::Extension& Wallet::extension(int index) const {
  return extension_.Get(index);
}
inline ::wallet::Extension* Wallet::mutable_extension(int index) {
  return extension_.Mutable(index);
}
inline ::wallet::Extension* Wallet::add_extension() {
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::wallet::Extension >&
Wallet::extension() const {
  return extension_;
}
inline ::google::protobuf::RepeatedPtrField< ::wallet::Extension >*
Wallet::mutable_extension() {
  return &extension_;
}

// optional string description = 11;
inline bool Wallet::has_description() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Wallet::set_has_description() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Wallet::clear_has_description() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Wallet::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Wallet::description() const {
  return *description_;
}
inline void Wallet::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Wallet::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Wallet::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Wallet::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Wallet::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 key_rotation_time = 13;
inline bool Wallet::has_key_rotation_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Wallet::set_has_key_rotation_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Wallet::clear_has_key_rotation_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Wallet::clear_key_rotation_time() {
  key_rotation_time_ = GOOGLE_ULONGLONG(0);
  clear_has_key_rotation_time();
}
inline ::google::protobuf::uint64 Wallet::key_rotation_time() const {
  return key_rotation_time_;
}
inline void Wallet::set_key_rotation_time(::google::protobuf::uint64 value) {
  set_has_key_rotation_time();
  key_rotation_time_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace wallet

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wallet::Key_Type>() {
  return ::wallet::Key_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wallet::TransactionConfidence_Type>() {
  return ::wallet::TransactionConfidence_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wallet::TransactionConfidence_Source>() {
  return ::wallet::TransactionConfidence_Source_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wallet::Transaction_Pool>() {
  return ::wallet::Transaction_Pool_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wallet::Transaction_Purpose>() {
  return ::wallet::Transaction_Purpose_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::wallet::Wallet_EncryptionType>() {
  return ::wallet::Wallet_EncryptionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_multibit_2eproto__INCLUDED
